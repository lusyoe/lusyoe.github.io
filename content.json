[{"title":"Hibernate+JNDI配置","date":"2016-10-05T09:08:38.000Z","path":"2016/10/05/Hibernate-JNDI配置/","text":"刚开始使用JNDI，网上也查了不少资料，磕磕盼盼鼓捣了大半天才成功，在此记录一下。 介绍首先还是再啰嗦两句，介绍一下JNDI技术。JNDI是Java 命名和目录接口（Java Naming and Directory Interface，JNDI）的简称.从一开始就一直是 JavaEE 企业的核心技术之一。在JMS，JMail,JDBC,EJB等技术中，就大量应用的这种技术。 服务端容器配置(基于Tomcat)修改conf/server.xml文件，在GlobalNamingResources节点中添加 12345678910&lt;Resource name=\"jdbc/bookshop\" auth=\"Container\" scope=\"jdbc/bookshop\" type=\"javax.sql.DataSource\" driverClassName=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql://192.168.1.2:3306/bookshop\" username=\"root\" password=\"lu123\" maxActive=\"50\" maxIdle=\"30\" maxWait=\"10000\" /&gt; 然后接着再修改conf/context.xml文件，在Context节点中添加引用12345&lt;ResourceLink global=\"jdbc/bookshop\" name=\"jdbc/bookshop\" auth=\"Container\" type=\"javax.sql.DataSource\"/&gt; 很简单，这个服务器就配置好了，最后还需要重启一下tomcat服务，别忘啦。。接下来再看看项目配置。 项目配置项目只是一个简单的测试Demo，首先看看pom.xml文件项目依赖配置。 ### 项目依赖12345678910111213141516171819202122232425262728293031323334dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate&lt;/groupId&gt; &lt;artifactId&gt;hibernate-core&lt;/artifactId&gt; &lt;version&gt;5.1.0.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;mysql&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;6.0.3&lt;/version&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;!-- Java Servlet --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 这里因为我们使用JNDI技术，数据库的驱动由Tomcat容器提供，所以我们的项目中就不需要再依赖它了，这样一来灵活性也非常高了。 Hibernate配置这里列出简单的hibernate配置，新建一个hibernate.cfg.xml文件放置到项目classpath中，我用的是Idea，也可以放在resources目录中，添加文件内容： hibernate.cfg.xml123456789101112131415161718192021222324252627&lt;?xml version='1.0' encoding='utf-8'?&gt;&lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"&gt;&lt;hibernate-configuration&gt; &lt;session-factory&gt; &lt;!--&lt;property name=\"connection.url\"&gt;jdbc:mysql://192.168.1.2:3306/bookshop&lt;/property&gt;--&gt; &lt;!--&lt;property name=\"connection.driver_class\"&gt;com.mysql.jdbc.Driver&lt;/property&gt;--&gt; &lt;!--&lt;property name=\"connection.username\"&gt;root&lt;/property&gt;--&gt; &lt;!--&lt;property name=\"connection.password\"&gt;lu123&lt;/property&gt;--&gt; &lt;!-- JNDI --&gt; &lt;property name=\"connection.datasource\"&gt;java:comp/env/jdbc/bookshop&lt;/property&gt; &lt;property name=\"hbm2ddl.auto\"&gt;update&lt;/property&gt; &lt;property name=\"show_sql\"&gt;true&lt;/property&gt; &lt;property name=\"format_sql\"&gt;true&lt;/property&gt; &lt;property name=\"dialect\"&gt;org.hibernate.dialect.MySQL5Dialect&lt;/property&gt; &lt;property name=\"hibernate.current_session_context_class\"&gt;thread&lt;/property&gt; &lt;mapping resource=\"Users.hbm.xml\"/&gt; &lt;/session-factory&gt;&lt;/hibernate-configuration&gt; 可以看到，在使用JNDI之前需要配置一大堆的东西，如:url，数据库连接用户名，密码，驱动类等等。现在使用JNDI之后，只需要提供一个数据源即可，确实比之前方便不少。注意配置文件中映射了一个Users.hbm.xml文件，这个文件其实就是用hibernate映射一个JavaBean的配置文件，不过貌似现在都提倡使用注解的方式了。但是还是有可能会遇到需要维护旧的项目，而旧的项目大都是使用xml来进行配置的，所以还是了解下这个比较好。 Users.hbm.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;!DOCTYPE hibernate-mapping PUBLIC \"-//Hibernate/Hibernate Mapping DTD 3.0//EN\" \"http://www.hibernate.org/xsd/hibernate-mapping-3.0.dtd\"&gt;&lt;hibernate-mapping&gt; &lt;class name=\"com.example.hibernate.bean.Users\" table=\"users\" catalog=\"bookshop\"&gt; &lt;id name=\"id\" type=\"java.lang.Integer\"&gt; &lt;column name=\"Id\"/&gt; &lt;generator class=\"native\"&gt;&lt;/generator&gt; &lt;/id&gt; &lt;property name=\"loginName\" type=\"java.lang.String\"&gt; &lt;column name=\"LoginName\" length=\"50\"/&gt; &lt;/property&gt; &lt;property name=\"loginPwd\" type=\"java.lang.String\"&gt; &lt;column name=\"LoginPwd\" length=\"16\"/&gt; &lt;/property&gt; &lt;/class&gt;&lt;/hibernate-mapping&gt; 很简单，就不做过多介绍，根据这个再创建JavaBean类就行，就不贴那个了。 web.xml配置一般JavaEE web项目都需要一个web.xml文件的，不过貌似随着Spring的潮流，提倡不需要web.xml也可以了。。但还是那句老话，旧的项目正赚钱着不可能都给推掉了。 web.xml 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"utf-8\" ?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\" version=\"3.1\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;servlet&gt; &lt;servlet-name&gt;user&lt;/servlet-name&gt; &lt;servlet-class&gt;com.example.hibernate.controller.UserController&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;user&lt;/servlet-name&gt; &lt;url-pattern&gt;/user&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 这个文件很简单，就只配置一个Servlet，项目配置的东西基本上就都说完了，现在再来看看项目代码结构了。 项目代码结构我使用的是IntelliJ IDEA，据说这个是Java中最好的IDE。。项目结构也很简单，能省的都给省了。先看一下HibernateSessionFactory.java这个文件，它主要就是在项目中引入Hibernate的配置，并获取到Session，而我们增删改查等操作就都是通过这个Session来控制的。 HibernateSessionFactory.java 1234567891011121314151617181920212223package com.example.hibernate;import org.hibernate.Session;import org.hibernate.SessionFactory;import org.hibernate.cfg.Configuration;/** * Created by Administrator on 2016/9/25. */public class HibernateSessionFactory &#123; private static Configuration configure; private static SessionFactory sessionFactory; static &#123; configure = new Configuration().configure(); sessionFactory = configure.buildSessionFactory(); &#125; public static Session getSession() &#123; return sessionFactory.openSession(); &#125;&#125; 也很简单的操作，就是根据配置文件来获取Session的，而Hibernate的实际操作就是通过这个Session来完成的。我们先从DAO层开始，来看下BaseHibernateDAO.java文件 BaseHibernateDAO.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package com.example.hibernate.dao;import com.example.hibernate.HibernateSessionFactory;import org.hibernate.Session;import org.hibernate.Transaction;import java.io.Serializable;/** * Created by Administrator on 2016/9/25. */public abstract class BaseHibernateDAO &#123; protected void add(Object object) &#123; Transaction tx = null; // 获取session Session session = HibernateSessionFactory.getSession(); try &#123; // 开始事务 tx = session.beginTransaction(); // 持久化操作 session.save(object); tx.commit(); &#125; catch (Exception e) &#123; if (tx != null) &#123; // 回滚事务 tx.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; // 关闭session session.close(); &#125; &#125; protected Object get(Class cla, Serializable id) &#123; Object obj = null; Session session = HibernateSessionFactory.getSession(); try &#123; obj = session.get(cla, id); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; return obj; &#125; protected void delete(Object object) &#123; Transaction tx = null; Session session = HibernateSessionFactory.getSession(); try &#123; tx = session.beginTransaction(); session.delete(object); tx.commit(); &#125; catch (Exception e) &#123; if (tx != null) &#123; tx.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125; protected void update(Object object) &#123; Transaction tx = null; Session session = HibernateSessionFactory.getSession(); try &#123; tx = session.beginTransaction(); session.update(object); tx.commit(); &#125; catch (Exception e) &#123; if (tx != null) &#123; tx.rollback(); &#125; e.printStackTrace(); &#125; finally &#123; session.close(); &#125; &#125;&#125; 这里也很简单，毕竟只是为了演示测试使用，真正的项目肯定不应该这样的。再来看看UserDAO.java文件，它主要是提供了上层能够操作的接口。 12345678910111213141516package com.example.hibernate.dao;import com.example.hibernate.bean.Users;/** * Created by Administrator on 2016/9/25. */public interface UserDAO &#123; void add(Users users); void delete(Users users); Users load(Integer id); void update(Users users);&#125; UserDAOImpl.java也没什么内容，其实就是我懒。。。 123456789101112131415161718192021222324package com.example.hibernate.dao;import com.example.hibernate.bean.Users;/** * Created by Administrator on 2016/9/25. */public class UserDAOImpl extends BaseHibernateDAO implements UserDAO &#123; public void add(Users users) &#123; super.add(users); &#125; public void delete(Users users) &#123; super.delete(users); &#125; public Users load(Integer id) &#123; return (Users) super.get(Users.class, id); &#125; public void update(Users users) &#123; super.update(users); &#125;&#125; 再来看看关键的Controller，主要就是响应web页面的请求的。 UserController.java 12345678910111213141516171819202122232425262728293031323334package com.example.hibernate.controller;import com.example.hibernate.bean.Users;import com.example.hibernate.dao.UserDAO;import com.example.hibernate.dao.UserDAOImpl;import javax.servlet.ServletException;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import java.io.IOException;import java.io.PrintWriter;/** * Created by Administrator on 2016/10/2. */public class UserController extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; UserDAO dao = new UserDAOImpl(); Users load = dao.load(3); PrintWriter writer = resp.getWriter(); writer.print(&quot;get = &quot; + load.toString()); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 也很简单，相信初学者也都能看懂，当然了我也是一个Web的初学者，之前都是做Android应用开发，现在是做Android系统Framework开发，而未来我打算想做Web后端开发，努力学习ing… 哦，对了。还有最关键的数据库方面还没说。。 数据库配置 使用Navicat for MySQL可以很方便设计数据库表和进行增删改查等操作，挺强大的一个功能是还能从excel表格中导入数据。 总结好了，一个简单Hibernate+JNDI配置就说到这吧。当然，配置的方式有很多种，但是只要适合自己就好了。这里最后再吐槽一句，网上的教程一大堆也太不完整了，东一点西一点的，说一大堆还是不会用。即使是只作为自己的一个笔记，起码也要说清楚一点比较好吧，万一后来自己再来翻的时候都看不懂，那就笑了。而作为一个教程类，起码得要能run跑起来吧？","tags":[{"name":"Hibernate","slug":"Hibernate","permalink":"https://lusyoe.github.io/tags/Hibernate/"},{"name":"JNDI","slug":"JNDI","permalink":"https://lusyoe.github.io/tags/JNDI/"}]},{"title":"Jenkins远程部署war包到tomcat","date":"2016-09-27T13:46:33.000Z","path":"2016/09/27/Jenkins远程部署war包到tomcat/","text":"网上关于这个的文章也是数不胜数了，但是稍不注意还是会掉坑里了，好不容易配置成功在这里记录一下。关于怎么搭建Jenkins自动构建之前已经写过，这里就再补充一下自动远程部署的情况。 准备在开始之前，服务器上需要有安装好环境，如：JDK，Tomcat等配置好环境变量同时，在Jenkins和Gitlab上创建好项目。 项目文件配置来依次看一下关于项目的文件配置，包括Maven的配置等。 pom.xml配置1234567891011121314151617181920212223&lt;packaging&gt;war&lt;/packaging&gt;&lt;properties&gt; &lt;warPackageName&gt;spring&lt;/warPackageName&gt; &lt;tomcat.deploy.server&gt;tomcat8&lt;/tomcat.deploy.server&gt; &lt;tomcat.deploy.serverUrl&gt;http://192.168.1.2:8088/manager/text&lt;/tomcat.deploy.serverUrl&gt;&lt;/properties&gt;&lt;build&gt; &lt;finalName&gt;spring&lt;/finalName&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt; &lt;artifactId&gt;tomcat-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.1&lt;/version&gt; &lt;configuration&gt; &lt;server&gt;$&#123;tomcat.deploy.server&#125;&lt;/server&gt; &lt;url&gt;$&#123;tomcat.deploy.serverUrl&#125;&lt;/url&gt; &lt;path&gt;/$&#123;warPackageName&#125;&lt;/path&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 我这里tomcat版本使用的8，如果使用的是tomcat6.x的话，serverUrl需要改为http://192.168.1.2:8080/manager。在这里&lt;tomcat.deploy.server&gt;tomcat8&lt;/tomcat.deploy.server&gt;，其中tomcat8是需要在Maven的.settings.xml文件中配置的。 Maven settings配置~/.m2/.settings.xml 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;servers&gt; &lt;server&gt; &lt;id&gt;nexus-snapshots&lt;/id&gt; &lt;username&gt;admin&lt;/username&gt; &lt;password&gt;lhy123&lt;/password&gt; &lt;/server&gt; &lt;server&gt; &lt;id&gt;tomcat8&lt;/id&gt; &lt;username&gt;deployer&lt;/username&gt; &lt;password&gt;dev&lt;/password&gt; &lt;/server&gt; &lt;/servers&gt; &lt;mirrors&gt; &lt;mirror&gt; &lt;id&gt;nexus&lt;/id&gt; &lt;name&gt;internal nexus repository&lt;/name&gt; &lt;url&gt;http://192.168.1.2:8081/repository/maven-central/&lt;/url&gt; &lt;mirrorOf&gt;*&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt;&lt;/settings&gt; 在这里主要是看server中的tomcat8配置，需要tomcat的用户名和密码。至于其他的是关于nexus的配置，以后有机会再写一篇详细说明Nexus的吧。tomcat的用户名和密码就需要我们到服务器上去配置了。 服务器配置服务器上主要是tomcat用户配置和Maven settings配置。是的，本地配置那个是方便在本地就可以直接部署到服务器，但是如果是用Jenkins来帮我们自动的部署的话就需要在服务器上也配置一下Maven Settings了，否则在构建好后是无法进行远程部署的，因为不知道tomcat的用户名和密码。在这里我们直接复制本地的.settings.xml文件到服务器就好，也有个地方需要注意了。.settings.xml这个文件不是随便放的，需要放到启动jenkins的用户的那个home目录下面的.m2/目录中。因为我是直接从Jenkins官网下载了war包，然后丢到tomcat中运行的。所以这里我需要将.settings.xml文件放到/usr/share/tomcat8/.m2/中。需要注意的是文件权限问题，我是为了偷懒直接用系统# apt-get install tomcat8安装的，系统会自动创建tomcat8用户。所以还需要额外执行一条命令：# chown tomcat8:tomcat8 .settings.xml即可。如果是自己从apache tomcat官网下载的压缩包的话，就看你启动tomcat服务用的哪个系统用户了，就把.settings.xml文件丢到那个用户的$HOME/.m2/下即可。 tomcat配置先在tomcat用户配置文件中添加一个用户，并给予manager-script权限就行。在我这里是编辑/etc/tomcat8/tomcat-users.xml文件123456&lt;tomcat-users&gt; &lt;role rolename=\"admin-gui\"/&gt; &lt;role rolename=\"manager-gui\"/&gt; &lt;user username=\"tomcat\" password=\"tomcat\" roles=\"admin-gui,manager-gui\"/&gt; &lt;user username=\"deployer\" password=\"dev\" roles=\"manager-script\"/&gt; &lt;/tomcat-users&gt; 主要看deployer这个用户就行了。 Jenkins构建配置好了，最后再说一下，在Jenkins中执行的构建命令这里需要注意,执行的是mvn tomcat:redeploy。网上很多教程说的是mvn tomcat7:redeploy，我这边死活不行，总是报错。No plugin found for prefix &#39;tomcat7&#39; in the current project.暂时不知道是什么原因，先不管了。 总结做开发的就是一路趟坑啊，尤其是web方面。感觉就这么一点小小的东西都折腾了好一番，真是路漫漫兮其修远矣。但是为了前途咱还是得一路顶上去呢，吾必将上下而求索~ 致还在年轻奋斗的我们。。","tags":[{"name":"CI持续集成","slug":"CI持续集成","permalink":"https://lusyoe.github.io/tags/CI持续集成/"}]},{"title":"Spring Data JPA使用JpaRepository自动装配报No qualifying bean of type错误","date":"2016-09-22T13:50:31.000Z","path":"2016/09/22/Spring-Data-JPA使用JpaRepository自动装配报No-qualifying-bean-of-type错误/","text":"今天遇到一个问题折腾蛮久的，在这里记录一下。毕竟是才刚开始使用Jpa这个技术，总是会遇到各种配置问题。使用Spring Data Jpa非常的方便，一些简单的操作基本上都不用写具体的实现，直接写一个接口继承JpaRepository就行了，注意需要带有一个泛型。k = 表映射的实体类，value = 表的Id类型。 在使用的时候直接自动装配就好。 12@Autowiredprivate xxxRepository repository; 然后就可以使用一些常用的数据库操作，如：findxxx、delete、save。不过默认没有update方法，如果需要的话，就要在接口中再添加。 好了，说下我遇到的那个问题。Caused by: org.springframework.beans.factory.NoSuchBeanDefinitionException: No qualifying bean of type [com.example.rest.repository.UserRepository] found for dependency: expected at least 1 bean which qualifies as autowire candidate for this dependency. Dependency annotations: {}写个Demo自动装配的时候，测试报这个错误。检查一下spring配置文件，才发现少了声明repository所在包位置。 12&lt;!-- 表示JPA Repository所在的包 --&gt;&lt;jpa:repositories base-package=\"com.example.rest.repository\"/&gt; 添加以上配置即可。","tags":[{"name":"Web","slug":"Web","permalink":"https://lusyoe.github.io/tags/Web/"},{"name":"Spring","slug":"Spring","permalink":"https://lusyoe.github.io/tags/Spring/"}]},{"title":"Spring Data JPA配置出现Not a managed type错误","date":"2016-09-20T11:25:46.000Z","path":"2016/09/20/Spring-Data-JPA配置出现Not-a-managed-type错误/","text":"最近在学习Spring框架，配置数据库连接的时候出现这个错误。1Caused by: java.lang.IllegalArgumentException: Not a managed type: class ... 才刚学不久，被这个问题折腾了有一会，后来检查的时候无意中发现在persistence.xml文件漏了东西啦。 123&lt;!-- JPA的提供者 --&gt;&lt;provider&gt;org.hibernate.jpa.HibernatePersistenceProvider&lt;/provider&gt;&lt;class&gt;com.example.usermanage.model.User&lt;/class&gt; 之前在上面的配置的时候，少添加了&lt;class&gt;com.example.usermanage.model.User&lt;/class&gt;。","tags":[{"name":"Web","slug":"Web","permalink":"https://lusyoe.github.io/tags/Web/"},{"name":"Spring","slug":"Spring","permalink":"https://lusyoe.github.io/tags/Spring/"}]},{"title":"Debian 8桌面安装Nvidia GTX960显卡驱动","date":"2016-09-04T12:55:52.000Z","path":"2016/09/04/Debian-8桌面安装Nvidia-GTX960显卡驱动/","text":"前言还是上次那个朋友，帮他把组装电脑装好Debian系统后，首先是出现USB无线网卡驱动问题，现在又是出现显卡驱动问题。因为没有安装显卡闭源驱动，每次开机都会出现提示没有使用硬件加速，不推荐使用之类的信息，整个系统界面也显示的很模糊。这是因为默认使用的是内核中自带的开源驱动，效果肯定很差了。没办法了，只能叫我来帮他安装驱动了。 驱动安装好歹也算是一名Linux的老鸟了，肯定不能像一个新手一样去百度搜那些杂乱、过时的信息。刚开始我也经常这样做，结果搞得系统总是出问题，经过了多次重装系统的惨烈经历后，慢慢就总结出来经验了。像这种东西，必须要先去查看官方wiki。如果官方还没有支持的话，再去google搜索第三方是如何安装的。不过这次很幸运，目前Debian官方已经支持Nvidia GTX960显卡驱动安装了，不过如果系统是Debian稳定版的话就必须要添加backports源了。 查看显卡型号# lspci -nn |grep VGA 以下命令确保都在root用户下运行。 添加backports源# echo &quot;deb http://httpredir.debian.org/debian jessie-backports main contrib non-free&quot; &gt;&gt; /etc/apt/sources.list更新源# apt-get update 安装Linux headers因为驱动会依赖一些Linux headers库。# apt-get install linux-headers-$(uname -r|sed &#39;s,[^-]*-[^-]*-,,&#39;) 安装驱动# apt-get install -t jessie-backports nvidia-driver安装的过程中可能会提示与当前的正在使用的开源驱动nouveau冲突，不用理会确定即可。安装程序会将开源驱动默认添加到blacklist中，安装成功后，需要重启一下系统就好啦。 总结驱动安装好后，重启进入系统，再也没有那个未使用硬件加速提示了，整个界面也显示的非常清晰。有和没有驱动区别还是相当大的，之前都听别人说Linux中显卡驱动怎么怎么的坑。虽然我之前也没折腾过这个，一是：我的笔记本比较老式了i3 u，只使用cpu中的集显，也没遇到过显卡驱动方面的坑。二是：自从买了E5的服务器装好Debian后，我就把笔记本换回了win7，服务器当然不需要图形界面和显卡啦，而Windows的驱动安装更是简单，不多说了。 这次帮朋友安装，才知道了，Linux现在在桌面方面长进还是非常大的。最后是瑾记一句话：千万不要再随意帮别人装系统。千万不要再随意帮别人装系统。千万不要再随意帮别人装系统。 参考资料 Debian Nividia显卡驱动wiki： https://wiki.debian.org/NvidiaGraphicsDrivers最新驱动版本支持的型号： http://us.download.nvidia.com/XFree86/Linux-x86_64/352.79/README/supportedchips.html","tags":[{"name":"显卡驱动","slug":"显卡驱动","permalink":"https://lusyoe.github.io/tags/显卡驱动/"},{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://lusyoe.github.io/tags/Linux驱动/"}]},{"title":"MySQL基础之视图实战篇","date":"2016-09-03T02:05:49.000Z","path":"2016/09/03/MySQL基础之视图实战篇/","text":"创建视图基本语法：1234CREATE [OR REPLACE][ALGORITHM = &#123;UNDEFINED | MERGE |TEMPTABLE&#125;] VIEW view_name [(column_list)] AS SELECT_statement [WITH[CASCADED | LOCAL] CHECK OPTION] 其中，CREATE 表示创建新的视图，REPLACE表示替换已经创建的视图;ALGORITHM表示视图选择的算法；view_name 为视图的名称，column_list为属性列；SELECT_statement表示SELECT语句;WITH [CASCADED | LOCAL] CHECK OPTION参数表示视图在更新时保证在视图的权限范围之内。 在单表上创建视图视图是基于表之上的虚拟表，所以必须要先有表。 创建表 12345CREATE TABLE t( id INT PRIMARY KEY AUTO_INCREMENT, quantity INT, price DOUBLE); 创建视图 1CREATE VIEW view_t AS SELECT quantity, price, quantity*price AS total FROM t; 在多表上创建视图 创建表表1:12345CREATE TABLE student( id INT PRIMARY KEY AUTO_INCREMENT, number INT, name VARCHAR(20)); 表2:12345CREATE TABLE stutent_info( id INT PRIMARY KEY AUTO_INCREMENT, class VARCHAR(10), address VARCHAR(20)); 创建视图12CREATE VIEW stu_glass(id, name, glass) AS SELECT student.id, student.name, stutent_info.classFROM student, student_info WHERE student.id=student_info.id; 查看视图视图创建好了后，可以查看视图的一些信息，如以下几种: 查看视图描述与表类似DESC stu_glass; 查看视图定义SHOW CREATE VIEW stu_glass; 修改视图当数据库中的基本表某些字段发生变化的时候，可以通过修改视图来保持与基本表的一致性。在Mysql中可以通过CREATE OR REPLACE VIEW语句和ALTER语句来修改视图。 CREATE OR REPLACE VIEW语句使用改语句时，如果视图已经存在则对视图进行修改，当视图不存在时，就创建视图。1CREATE OR REPLACE VIEW view_t AS SELECT * FROM t; 可通过DESC view_t语句来查看修改后的视图结构。 ALTER语句1ALTER VIEW view_t AS SELECT quantity FROM t; 更新视图更新视图是指通过视图来插入、更新、删除表中的数据，因为视图是一个虚拟表，其中没有数据。通过视图更新的时候都是转到基本表上进行更新的，如果对视图增加或者删除记录，实际上是对其基本表增加或者删除记录。 UPDATE语句 1UPDATE view_t SET quantity=5; INSERT语句在基本表中插入语句，其关联视图也会进行相应改变的。 12INSERT INTO t VALUES(2, 2);SELECT * FROM view_t; DELETE语句在视图中删除一行数据，其基本表也会进行相应的删除。 12DELETE FROM view_t WHERE price=50;SELECT * FROM t; 删除视图当视图不再需要时，可以将其删除，删除一个或多个视图可以使用DROP VIEW语句。语法如下：123DROP VIEW [IF EXISTS] view_name [, view_name]... [RESTRICT | CASCADE] 例如：1DROP VIEW IF EXISTS stu_glass;","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lusyoe.github.io/tags/MySQL/"},{"name":"视图","slug":"视图","permalink":"https://lusyoe.github.io/tags/视图/"}]},{"title":"Debian桌面编译安装Tenda U1 USB无线网卡驱动","date":"2016-09-02T15:14:01.000Z","path":"2016/09/02/Debian桌面编译安装Tenda-U1-USB无线网卡驱动/","text":"前序朋友新组装了一台PC,应他的要求帮他装了一个Debian Linux系统。由于没办法直接用网线连着PC,他就买了一个USB的无线网卡连上无线路由就好。结果Linux系统由于驱动问题，不识别那个网卡。没办法了，系统是我帮装的，只好叫我来给他弄这个了。一番折腾过后顺利安装成功了，在这里记录一下。 驱动安装 从官方网站下载适用于Linux的驱动# wget http://down.tenda.com.cn/uploadfile/2016/U1_linux.zip 编译 解压zip包# unzip U1_linux.zip 进入解压后的目录# cd RTL8192EU_linux_v4.3.15_14701_BTCOEX20150615-41.20150715 执行自动编译脚本# sh install.sh 解决依赖问题如果编译过程中出现类似/lib/modules/3.16.0-4-amd64/build No such file or directory 错误。那么需要安装额外的编译依赖库。 1# sudo apt-get install linux-headers-`uname -r` 然后继续编译即可# sh install.sh 如果不是使用root用户编译的话,中间需要输入几次root密码。最后出现The Setup Script is completed !就表示编译安装成功了，这时候点开桌面的网络连接工具应该就可以扫描到热点了。 总结看起来挺简单的，但是对于新手来说还是很不容易的。腾达的官方文档倒是挺全的，但是全英文不说，信息太大而全了。一般新手很难找到有用的信息。就比如说这次编译依赖的问题，我就没有从文档中找到。","tags":[{"name":"Linux驱动","slug":"Linux驱动","permalink":"https://lusyoe.github.io/tags/Linux驱动/"},{"name":"USB","slug":"USB","permalink":"https://lusyoe.github.io/tags/USB/"}]},{"title":"MySQL基础之视图理论篇","date":"2016-08-29T15:15:05.000Z","path":"2016/08/29/MySQL基础之视图理论篇/","text":"视图概述视图是一个或者多个表中导出的，视图的行为与表非常的相似，但视图是一个虚拟表。在视图中用户可以使用SELECT语句查询数据，以及使用INSERT、UPDATE、DELETE修改记录。从MySQL 5.0开始可以使用视图，视图可以使用户操作方便，而且可以保障数据库系统的安全。 视图的含义视图是一个虚拟表，是从数据库中一个或多个表中导出来的表。视图还可以从已经存在的视图的基础上定义。视图一经定义便存储在数据库中，与其相对应的数据并没有像表那样在数据库中再存储一份，通过视图看到的数据只是存放在基本表中的数据。对视图的操作与对表的操作一样，可以对其进行查询、修改和删除。当对通过视图看到的数据进行修改时，相应的基本表数据也要发生变化；同时，若基本表的数据发生变化，则这种变化也可以自动的反映到视图中。 视图的作用与直接从数据表中读取相比，视图有以下优点： 简单化看到的就是需要的。视图不仅可以简化用户对数据的理解，也可以简化他们的操作。那些被经常使用的查询可以被定义为视图，从而使得用户不必为以后的操作每次指定全部的条件。 安全性通过视图用户只能查询和修改他们所能见到的数据。数据库中的其他数据则既看不见也取不到。数据库授权命令可以使每个用户对数据库的检索限制到特定的数据库对象上，但不能授权到数据库特定行和特定的列上。通过视图，用户可以被限制在数据的不同子集上： 使用权限可被限制在基表的行的子集上; 使用权限可被限制在基表的列的子集上; 使用权限可被限制在基表的行和列的子集上; 使用权限可被限制在多个基表的连接所限定的行上; 使用权限可被限制在基表中的数据的统计汇总上; 使用权限可被限制在另一视图的一个子集上，或是一些视图和基表表合并后的子集上。 逻辑数据独立性视图可帮助用户屏蔽真实表结构变化带来的影响。视图就相当于一个抽象层，用户面向的是抽象后的而不是底层表的细节。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lusyoe.github.io/tags/MySQL/"},{"name":"视图","slug":"视图","permalink":"https://lusyoe.github.io/tags/视图/"}]},{"title":"Gitlab CI Multi Runner搭建CI持续集成环境","date":"2016-08-29T12:32:56.000Z","path":"2016/08/29/Gitlab-CI-Multi-Runner搭建CI持续集成环境/","text":"GitLab不仅仅只是代码托管的工具，它还集成了CI的功能，通过Gitlab CI Multi Runner工具可以更方便的搭建持续集成环境。在安装好GitLab之后还需要再安装一个叫gitlab-ci-multi-runner的工具。PS: 当然了肯定没有Jenkins那么强大，毕竟可用插件太多了。 安装gitlab-ci-multi-runner 官方多种安装方式由于众所周知(墙)的原因，还是推荐Gitlab CI Multi Runner 清华镜像 gitlab-runner命令介绍服务状态安装好runner之后就可以使用gitlab-runner命令了，可通过# gitlab-runner help查看命令帮助，更多命令详情可以查阅官方文档好了，让我们来先查看一下服务运行的状态。# gitlab-runner status输出以下内容，说明服务运行正常了。gitlab-runner: Service is running! 还有也可以通过以下命令查看，不过我更喜欢短一点的命令，后面都只使用gitlab-runner了。# gitlab-ci-multi-runner status 注册一个runner注册一个runner可以使用交互式和非交互式两种方式，默认使用交互式的。输入以下命令就可以开始交互式注册了，在这之前请确保Gitlab上面已经新建有项目了。# gitlab-runner register 123456789101112131415Running in system-mode.Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/ci):http://192.168.1.2/ci // 在这里输入gitlab安装的服务器ip/ci 即可Please enter the gitlab-ci token for this runner:eaYyokc57xxZbzAsoshT // 这里的token可通过Gitlab上的项目Runners选项查看，在下面贴一张截图Please enter the gitlab-ci description for this runner:[E5]: spring-demo // 这里填写一个描述信息，不太重要，看着填吧Please enter the gitlab-ci tags for this runner (comma separated):demo // 在这里填写tag信息，多个tag可通过逗号,分割。Registering runner... succeeded runner=eaYyokc5Please enter the executor: docker, docker-ssh, parallels, shell, ssh, virtualbox, docker+machine, docker-ssh+machine:shell // 在这里需要输入runner的执行方式，因为我的Gitlab和runner是安装在同一台服务器上的，直接输入shellRunner registered successfully. Feel free to start it, but if it&apos;s running already the config should be automatically reloaded!// 出现这样信息表示服务端的配置就已经成功结束了，如果需要使用到自动构建，还需要再添加一个配置文件，下面说说这个。 查看runner配置信息可通过以下命令进行查看# gitlab-runner list12Listing configured runners ConfigFile=/etc/gitlab-runner/config.tomlspring-demo Executor=shell Token=387ed6c05fef248d2183f9f45b9cda URL=http://192.168.1.2/ci 也可以直接打开配置文件进行查看# vim /etc/gitlab-runner/config.toml123456789101112131415161718192021concurrent = 1check_interval = 0[[runners]] name = \"spring-demo\" url = \"http://192.168.1.2/ci\" token = \"387ed6c05fef248d2183f9f45b9cda\" executor = \"shell\" [runners.ssh] [runners.docker] tls_verify = false image = \"\" privileged = false disable_cache = false [runners.parallels] base_name = \"\" disable_snapshots = false [runners.virtualbox] base_name = \"\" disable_snapshots = false [runners.cache] 删除注册信息如果发现register信息填写错误，或者不再使用了。可通过以下命令进行删除。 首先查看已注册过的信息# gitlab-runner list 12Listing configured runners ConfigFile=/etc/gitlab-runner/config.tomlspring-demo Executor=shell Token=387ed6c05fef248d2183f9f45b9cda URL=http://192.168.1.2/ci 开始删除# gitlab-runner unregister --url http://192.168.1.2/ci --token 387ed6c05fef248d2183f9f45b9cda其中–url参数可查看上面的URL=后面的值填写，–token参数就是上面的Token=后面的值，复制粘贴即可。 123Running in system-mode.Deleting runner... succeeded runner=387ed6c0 出现上面信息表示删除成功了。注意：这个操作是不可逆的，为了防止出错可以先备份一下/etc/gitlab-runner/config.toml配置文件 项目自动化构建配置配置好了runner，想要开始自动构建还需要在项目根目录添加一个.gitlab-ci.yaml文件。关于.gitlab-ci.yaml文件的配置说明可参考官方文档。下面贴一下我做测试Demo时使用的，不要笑，很简单只做演示用的。。.gitlab-ci.yaml123456789stages: - build - deployjob1: stage: build script: &quot;mvn package&quot;job2: stage: deploy script: &quot;mvn tomcat:redeploy -Dmaven.test.skip=truey -e -X&quot; 总结到这里关于CI持续集成的差不多就说那么多了，当然了还有很多都没说到，这就要看实际的项目需求进行相应的配置了。总的来说呢，gitlab-runner虽然跟Gitlab集成的比较好，但是功能方面还是有点不如老牌的Jenkins。不过它对Docker倒是支持的蛮好的，说起来我接触Docker也是挺早的了，它2013年开源，我2014年就开始接触了，并且2015年也在公司服务器上实际部署了，后面有时间再写点关于Docker的吧。不过跳槽后就用的少了，但愿别都忘了好:)。","tags":[{"name":"CI持续集成","slug":"CI持续集成","permalink":"https://lusyoe.github.io/tags/CI持续集成/"}]},{"title":"Jenkins+Gitlab搭建CI持续集成架构","date":"2016-08-28T12:54:20.000Z","path":"2016/08/28/Jenkins-Gitlab搭建CI持续集成架构/","text":"首先安装Jenkins和Gitlab很简单就不多说了，贴个地址Installing JenkinsInstall a GitLab CE需要注意的是，在中国大陆由于墙的问题，Gitlab下载非常的慢，有可能导致下载失败了。。在这里推荐一下清华大学镜像源，在国内速度杠杠的。Gitlab Community Edition 镜像使用帮助有兴趣的可以看看它们的镜像首页，目前支持的镜像挺多的，而且还在不断的增加呢。 安装Jenkins插件做持续集成，Jenkins默认安装后还需要再安装一些插件。安装插件很简单，通过浏览器进入安装好Jenkins的服务器首页——&gt;点击系统管理——&gt;管理插件——&gt;可选插件然后过滤查找以下插件，勾选安装即可 Git client plugin Git plugin Gitlab Hook Plugin 创建代码仓库添加Webhooks好了，让我们来开始实际操作吧先在Gitlab上创建一个仓库，然后在项目的设置中选择Webhooks，在URL上填http://[jenkins-ip]:8080/gitlab/build_now前面是jenkins服务器的IP,端口号默认是8080，如果服务器上有类似tomcat这样的程序占用端口，就需要更改端口号了，这里也就要相应的修改了。还有一种情况，如果是通过Jenkins官网下载的war包形式，这里的URL就要改为http://[jenkins-ip]:8080/jenkins/gitlab/build_now 创建Jenkins项目进入我们服务器的Jenkins首页——&gt;点击新建——&gt;输入一个项目名称——&gt;选择构建一个自由风格的软件项目(free-style)点击ok进入了项目配置页面，然后按以下步骤操作就好了 源码管理设置，选中Git，把刚刚从Gitlab上创建的项目地址复制过来，在这里推荐使用http的形式，避免因为权限的问题导致代码无法pull下来。 构建设置，继续往下拖看到构建选项，点击增加构建步骤，可以根据具体项目来选择，在这里以Web的Maven项目为例。选择Invoke top-level Maven targets，Maven Version可根据个人选择，如果要添加自己下载的版本，可在首页——&gt;系统管理——&gt;Global Tool Configuration全局工具配置下面找到Maven进行添加。推荐使用自己的Golas框中填写maven的执行命令，比如： 12packagetomcat:redeploy -Dmaven.test.skip=true -e -X 之后保存应用即可注意：这里不需要添加mvn命令，jenkins会自动帮我们添加的，还有每一个命令占单独一行。 自动化构建好了，基本上都配置完了，现在该我们编写程序代码了。只需要从Gitlab上把源码pull到本地，然后进行coding修改再push上去即可。Jenkins那边会监听到push的操作后就自动pull下载更新代码然后进行相应的构建部署了。进入到Jenkins项目，可以查看到构建历史下面正在构建的项目，点击项目编号，再点击Console Output控制台输出就可以查看构建过程的详细日志了。 总结当然了持续集成肯定没这么简单的，后面应该还要有自动Test测试，导出报告之类的。在这里只是搭建一个最基本最简单的持续集成框架。","tags":[{"name":"CI持续集成","slug":"CI持续集成","permalink":"https://lusyoe.github.io/tags/CI持续集成/"}]},{"title":"MySQL基础之索引实战篇","date":"2016-08-21T13:29:38.000Z","path":"2016/08/21/MySQL基础之索引实战篇/","text":"在上一篇已经较为全面的讲述了索引的理论，现在进行实战操作。 在这里只列出常用索引类型的操作，关于更多的索引分类参看MySQL基础之索引理论篇 索引的创建 创建表的时候创建索引普通索引123456CREATE TABLE IF NOT EXISTS book( bookid INT NOT NULL, year_pub YEAR NOT NULL, INDEX(year_pub)); 上面语句是在year_pub字段上创建索引的 唯一索引唯一索引只是多加了一个UNIQUE关键字，以下语句为在id字段上添加唯一索引并命名为UniqIdx123456CREATE TABLE IF NOT EXISTS perso( id INT NOT NULL, name CHAR(30) NOT NULL, UNIQUE INDEX UniqIdx(id)); 组合索引12345678CREATE TABLE IF NOT EXISTS employee( id INT NOT NULL, name CHAR(30) NOT NULL, age INT NOT NULL, info VARCHAR(255), INDEX MultiIdx(id, name, age)); 全文索引FULLTEXT全文索引可以用于全文搜索，但只有MyISAM存储引擎才支持，并且必须为CHAR、VARCHAR、TEXT列。 12345678CREATE TABLE person( id INT NOT NULL, name CHAR(30) NOT NULL, age INT NOT NULL, info VARCHAR(255), FULLTEXT INDEX FullTextIdx(info))ENGINE=MyISAM; 通过SHOW CREATE TABLE person;可查看创建表的过程。 在已经存在的表上创建索引主要是通过ALTER TABLE 和 CREATE INDEX 语句进行的，推荐使用CREATE INDEX 普通索引在perso表的name上建立名为PoNameIdx的普通索引 123ALTER TABLE perso ADD INDEX PoNameIdx(name(30));或者CREATE INDEX PoNameIdx ON perso(name(30)); 通过SHOW INDEX FROM perso;命令可以查看perso表当前的所有索引信息。 唯一索引123ALTER TABLE person ADD UNIQUE INDEX UniqNameIdx(name(30));或者CREATE UNIQUE INDEX UniqNameIdx ON person(name(30)); 组合索引123ALTER TABLE person ADD INDEX PoAgeAndInfo(age, info);或者CREATE INDEX PoAgeAndInfo ON person(age, info); 全文索引在这里需要注意，全文索引只能在存储引擎为MyISAM的表上使用。123ALTER TABLE person ADD FULLTEXT INDEX infoFTIdx(info);或者CREATE FULLTEXT INDEX infoFTIdx ON person(info); 如果该字段上已经存在了索引，可以先删除掉，然后再创建。 索引的删除相较于索引的创建，删除索引的操作就比较简单很多了。 ALTER TABLE删除索引遵循以下基本语法格式即可：ALTER TABLE table_name DROP INDEX index_name如：1ALTER TABLE person DROP INDEX infoFTIdx; DROP INDEX删除索引格式如下：DROP INDEX index_name ON table_name如： 1DROP INDEX PoNameIdx ON perso; 结语最后索引的实战大概就写这么多吧，这些都只是基本操作。实际开发中重点应该是如何选择索引。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lusyoe.github.io/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"https://lusyoe.github.io/tags/索引/"}]},{"title":"MySQL基础之索引理论篇","date":"2016-08-21T12:19:23.000Z","path":"2016/08/21/MySQL基础之索引理论篇/","text":"简介索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可极大提高数据库查询的速度。 索引的含义和特点索引是一个单独的、存储在磁盘上的数据库接口，它们包含着对数据表里索引记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定的行，所有MySQL列类型都可以被所有，对于相关列使用索引是提高查询操作速度的最佳途径。 由于索引是在存储引擎中实现的，因此采用不同的存储引擎的表支持的索引类型也不相同。MySQL中索引的存储类型有两种：BTREE和HASH，具体和表的存储引擎相关的是：MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。 索引的优点 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的查询速度，这也是创建索引的最主要的原因。 在实现数据的参考完整性方面，可以加速表和表之间的连接。 在使用分组和排序子句进行数据查询时，也可以显著的减少查询中分组和排序的时间。 索引的缺点 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件大小。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引的分类MySQL的索引可以分为以下几类： 普通索引和唯一索引 普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。 唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一， 主键索引是一种特殊的唯一索引，不允许有空值。 单列索引和组合索引 单列索引即一个索引只包含单个列，一个表可以有多个单列索引。 组合索引指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时， 索引才会被使用。使用组合索引时遵循最左前缀集合。 全文索引 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中 插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。 MySQL中只有MyISAM存储引擎支持全文索引。 空间索引 空间索引是对空间数据类型的字段建立的索引，MySQL中空间数据类型有4种， 分别是：GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展， 使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL， 最后空间索引只能在存储引擎为MyISAM的表中创建。 索引的设计原则 索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于获得良好的性能非常重要。 设计索引时，应该考虑以下准则： 索引并非越多越好，一个表如有大量的索引，不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，因为当表中的数据更改的同时，索引也会进行调整和更新。 避免对经常更新的表进行过多的索引，并且索引中的列尽可能少，而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。 数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。 在条件表达式中经常用到的不同值较多的列上建立索引，在不同值少的列上不要建立索引。比如在用户表的”性别”字段上只有”男”与”女”两个不同值，因此就无须建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。 在频繁进行排序或分组(即进行group by或order by操作)的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lusyoe.github.io/tags/MySQL/"},{"name":"索引","slug":"索引","permalink":"https://lusyoe.github.io/tags/索引/"}]},{"title":"Idea Maven项目无法下载依赖问题汇总","date":"2016-08-21T11:31:50.000Z","path":"2016/08/21/Idea-Maven项目无法下载依赖问题汇总/","text":"在使用IntelliJ IDEA开发Web的时候，刚开始总是遇到Maven的各种问题。现在总结一下关于无法下载依赖jar的问题。 依赖语法错误 有时候没注意，直接就这样写了：12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; 然而，像这种单个的依赖必须要添加到&lt;dependencies&gt;&lt;/dependencies&gt;中间才行。正确的做法应该是这样:1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可恨的是IDE也不提示个什么。。","tags":[{"name":"Maven","slug":"Maven","permalink":"https://lusyoe.github.io/tags/Maven/"}]},{"title":"回首感悟","date":"2016-08-20T13:42:22.000Z","path":"2016/08/20/回首感悟/","text":"人生总是充满着选择，每一个选择又会造成截然不同的结果。从13年毕业至今，感觉人生真的是变化很快啊。毕业后，毅然决然的选择了转行，到现在也算是差不多完全融入IT这一行了。很庆幸，当初并没有选择错误。虽然不是科班出身，但凭着一股浓厚的兴趣，能真正入行也是不容易了。 回首一下这3年 2013年6月正式毕业了和绝大多数人一样，我毕业后一段时间都是很茫然的状态，不知道到底要做什么，毕竟刚踏入社会，什么都不了解。我选择了回家，由于在毕业之前报考了学校的计算机二级考试，开始在家里自学计算机课程了，编程语言当然只有C了。经过了暑期的几个月学习，最终顺利的考过了，也算是给自己增加了不少信心吧。不过就这样想找工作还是早得很啊。。 2013年9月-12月 Java起航之后又开始自学Java了，当初学Java完全就是奔着Android去的，那时候Android太火了。学Java的过程中又报了计算机网络自考本科，开始全面系统的学习计算机课程了。 2014年3月-6月 自考之路2014年可以说是最重要的一年了，由于基础底子太差了，仅仅凭着几个月的学习完全赶不上来。当然了，自考可以说是一败涂地了，几次过后就已经完全放弃了。。在这期间最大的收获就是在武大表哥那里的生活了，完全可以说是表哥带着我从毕业后的迷茫期走出来的。让我真正的建立了一个成年人的思想，有了自己的思想和主见。那段时间思考的最多的就是人生了。我的人生到底要怎么走，自考的失败可以说差点让我放弃了走IT的路了，那段时间整个人也是懵的。也是表哥把我拉出来的，真的是要非常的感谢他了。 2014年7月-8月 初次踏入社会2014年的暑期，第一次走入社会寻找工作了，虽然之前在校的时候有过实习经验，但那是建筑行业的了。既然已经打算换行了，当然不想再找那方面的工作了。然而，现实就是这么的残酷，就我这水平什么都找不到。。 无奈只能找一些工厂先去锻炼下了在武汉，去过富士康，由于大专的毕业，居然不要。。好像那些小学毕业的才更吃香啊接连的找了好几个厂子，最后还是在人才市场，找到了一个愿意收我的小厂了。走入工厂才知道那有多么的辛苦啊，每天都是机械性的劳动，还有白班夜班的倒。。 结果自然不言而喻，在那里只做了一周，还是放弃不下计算机编程啊 2014年9月-12月 培训之旅在武汉，在网上搜一些计算机实习工作时，发现了培训机构。当然了咱好歹也是成年人了，肯定不会被他们所忽悠，什么包就业，推荐工作啥的，一个字都不会信。但是知识这东西，恰好是我目前最缺乏的，通过网上用人单位的招聘需求，很多东西也不懂。这方面培训机构还是很有经验的，通过到多个培训机构试听，最终还是选择了一个看起来靠谱点的。 培训内容主要为：Java基础、Web入门和Android就业Java基础由于之前有过自学，所以还是挺轻松的，几次测验基本在班里也是第一的Web入门：当时对Web没有太过关注，也就真的只是入个门啦，当然那个讲师还是挺有水平的最关键是Android了，当时真的是挺用心的了，基本上白天学完了，晚上继续敲代码到凌晨1,2点 时间就这样在充实的学习过程中过去了. 2015年2月-3月 工作工作培训终于结束了，也算是给我开启了一扇IT的大门吧，经过培训过后，我才感觉已经踏入IT门槛了。2015年2月过完年后，为了发展到深圳来了。刚开始找工作，真的觉得自己还是太嫩了，以至于快1个月才终于找到了一个像样的工作了。当然了，这里还有个小插曲，需要感谢一下当初的培训机构。为了找工作，像我这种出身的，简历当然得要伪造了(惭愧)，不然不用想了。。。新单位居然要打电话给之前的单位调查背景，幸好我当初保存了培训机构的前台号码。 2015年3月-2016年1月 Android实战终于终于我找到一份Android开发的工作了，虽然是面向Android TV端的…突然发现自己不会的还是有好多啊，压力有点大。但是日子总得过啊 每天下了班后回来继续看项目学习了，可怜原还以为能有个人带带呢，结果就我1个Android开发。 碰碰磕磕，差不多一年的时间就这样过去了，也差不多熟悉Android app的基本开发了。 在这期间由于意外情况，接触到了Android系统底层的东西了，比如：自己编译ROM刷到盒子里面，静默安装等等 也跟一些厂商有打过交道了，比如：深圳的兆驰、TCL、小霸王等第一次听说了，除了MTK，高通之外的芯片了，如：Amlogic、Rockchip第一次听说并使用了Docker第一次自己去制作.9 图第一次把自己学习到的东西都运用上了等等… 2016年2月-3月 Android系统由于种种原因，不得不从这家辞职了。是该考虑下一家的时候了。打算好了去南山发展，毕竟在深圳南山区才是IT科技氛围最浓厚的区域了。刚开始也找了好几家app的开发，不过貌似大部分都对我有系统开发经验有兴趣点，那我是该考虑一下方向了，毕竟相对于app来说，我对系统底层也是更有兴趣一点(讨厌UI)。。 最终在科技园附近找到了一家偏系统开发的工作了，我也没想到人生第一次薪水过万会来的如此之快。 刚入职肯定是要好好表现了，发现他们居然连版本控制工具都没用，文件都是copy来copy去的。咱现在也不是那种刚入行的嫩鸟了，而且对于系统源码来说，没有版本控制实在是太容易出错了。 由于之前在上一家的学习，知道了怎么搭建一整套源码管理。耗费一周的时间，成功的搭建起了gitlab + repo + git的源码管理系统。gitlab作为最上层的操作界面，项目组每个人接触最多的东西repo 来着google官方的Android系统源码管理工具，可以管理许多的git小仓库git 最底层当然是使用git了，最流行最适合最好的系统源码管理工具了 然而git毕竟学习成本较高啊，在我走之后他们就没法使用了。。。 2016年3月-至今 正式Android Framework Engineer是的，我只在上一家待一个月就跳槽走了，原因说起来很可笑，有时候星期六要加班，而且还是免费的…我不喜欢这样，虽然都说在IT这行加班是很普遍的，但是那也是要有相应的补贴才行啊。免费的工，抱歉我不会打。 经过了一周的找工作面试，最终我却选择了外包公司。整个行业都在说外包怎么怎么的坑，当然了不排除确实有那么一些。 但是这家能给出比我上一家还要多出50%的薪水，我没理由不去啊。入职之后就是直接到某手机厂商那上班了，是说长期驻场来着。跟他们的员工一样的工作上班等在这里加班还是挺少的，待遇也不错，真的很满意了 发现了外包也有不错啊，很多东西光只听别人说真的很容易造成误导。小时候都听说过小马过河故事呢 还有就是在大公司就是不一样，流程非常的严谨，整个的开发流程就跟我之前所经历的完全不一样。第一次见识到了code review、自动化Test等各种流程了，感觉学到了很多。 在这里我也被分配到了framework组，做一些中间层功能接口开发、移植和Bug的修复等工作 然而，时间过去我发现自己没有了对Android的热爱，少了当初的那一份激情了。在这个暑期，我又对Java大数据，分布式感兴趣了起来。不，应该说我始终对编程有着热爱，但是现在每天却很少coding了，而Android即使是app项目的代码量也不大。并没有充分的展现出现编程的艺术来。是的，编程不仅仅是一种技术，更应该是一种艺术。 话说，今年看书还是看的挺多的，光这个暑期就看完3本了《Head First 设计模式》、《MySQL 5.5》、《分布式Java应用》可以看到，基本都是为下一步做的技术储备了，相比上半年看的《深入理解Android》系列等Android系统开发方面书籍确实变化蛮大的。 我想我已经做好了选择，不管以后的结果如何，选择了就不会后悔~","tags":[{"name":"感悟总结","slug":"感悟总结","permalink":"https://lusyoe.github.io/tags/感悟总结/"}]},{"title":"Jenkins新建Maven项目构建出现mvn command execution faild","date":"2016-08-09T22:49:44.000Z","path":"2016/08/10/Jenkins新建Maven项目构建出现mvn-command-execution-faild/","text":"第一次用Jenkins作持续集成自动化构建，难免经验不足。安装好，一来就直接新建一个Maven任务，然后就立即构建了，结果控制台总是输出123FATAL: command execution failedjava.io.IOException: Cannot run program \"mvn\" (in directory).... 百度google，无果。最终发现了原来是Jenkins工具里没有配置Maven… 回到Jenkis主目录，点击左边的系统管理 点击全局工具配置(Global Tool Configuration) 拖到最下面发现有一个Maven项目，点击新增Maven,默认可以选择在线自动下载安装，如果本地已经安装了的话，可以去掉自动安装,输入安装的根路径。 最后保存应用一下，再尝试build，果然成功了^_^","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://lusyoe.github.io/tags/Jenkins/"}]},{"title":"Shadowsocks日志中failed to recv data in handshakeReceive2Callback的错误解决办法","date":"2016-07-27T15:12:30.000Z","path":"2016/07/27/Shadowsocks日志中failed-to-recv-data-in-handshakeReceive2Callback的错误解决办法/","text":"最近重装了一下Win7系统，装好常用软件后，突然发现上google的时候shadowsocks不能用了，但是在Linux下用的好好的，刚开始还以为是系统的问题，差点就再重装了。最后通过log日志分析，然后再通过VPN进行goole搜索(百度基本搜不到什么有效信息)，找到了胡大伟的官方网站的这篇blog，刚好解决了问题。:)123Win+r services.msc打开服务管理窗口在里面找到xlserviceplatform把这个服务禁用了。找到C:\\Program Files(x86)\\Common Files\\Thunder Network\\ServicePlatform\\XLSP.dll文件删除之即可 幕后真凶原来是迅雷，对国内这些东西已经是彻底无语了。 在这里感谢下胡大伟!","tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://lusyoe.github.io/tags/shadowsocks/"}]},{"title":"OpenWrt之Log篇","date":"2016-06-04T15:50:16.000Z","path":"2016/06/04/OpenWrt之Log篇/","text":"目录 简介 logread 上传到远程rsyslog服务器 配置rsyslog 处理问题 总结 简介我接触OpenWrt也不长，之所以关注log这个东西，主要是前段时间路由器总是断线，所以想要分析一下原因． logread在OpenWrt中可通过logread命令查看运行时的log日志，我一般都是通过ssh进行远程访问路由器的．不过每次查看log，都要登陆进去，然后不断的敲logread也是很麻烦的，正好OpenWrt的web设置界面中有设置上传日志的选项，在我这是 系统—&gt;日志里面 上传到远程rsyslog服务器由于之前每次看日志都不太方便，我们可以将日志文件上传到本地的Linux机器中，我一般使用的是Ubuntu/Debian系的，现在一般的Linux发行系统都已经预装了rsyslog了，因此我们只需要配置一下即可． 配置rsyslog首先配置服务端，也即是我们使用的Linux系统主机.$ sudo vim /etc/rsyslog.conf找到1234567# provides UDP syslog reception#module(load=\"imudp\")#input(type=\"imudp\" port=\"514\")# provides TCP syslog reception#module(load=\"imtcp\")#input(type=\"imtcp\" port=\"514\" 一般只需要打开TCP就好，不过为了还有其他用途可以将UDP的也全部都打开，除去相应的#注释即可．修改后的样子1234567# provides UDP syslog receptionmodule(load=\"imudp\")input(type=\"imudp\" port=\"514\")# provides TCP syslog receptionmodule(load=\"imtcp\")input(type=\"imtcp\" port=\"514\" 这样还没完，我们还需要配置log存放的位置．进入/etc/rsyslog.d/目录，新建一个router.conf文件编辑添加12:fromhost-ip, isequal, \"192.168.1.1\" /var/spool/rsyslog/router.log&amp;~ 192.168.1.1表示路由器的地址后面路径就表示了上传到本地主机的log地址了最后的符号&amp;~表示了一个重定向规则，被用来告知rsyslog守护进程停止对日志消息的进一步处理，并且不要在本地写入。如果没有使用该重定向规则，那么所有的远程消息都会在写入上述描述的日志文件之外同时被写入到本地日志文件，这就意味着日志消息实际上被写了两次。 然后如果还有什么特殊需求的话，比如：像系统日志一样，自动打包之类的可以在/etc/logrotate.d/目录下面新建文件，然后进行添加．在这里我偷个懒，直接写在rsyslog文件里面． $ sudo vim /etc/logrotate.d/rsyslog随便找一个规则，将我们路由器log存放的地址写在上面即可 最后还有，需要重启一下rsyslog系统服务$ sudo systemctl restart rsyslog.service 查看一下是否在监听$ sudo netstat -tulpn |grep rsyslogd 以上服务端配置好了，客户端也就是路由器那里就很好配了．可以通过可视化的web界面进行管理，也可以直接命令行登陆进路由器,然后改配置文件的方式． 下面是我的路由器管理界面 改配置文件的话，就直接ssh连进路由器# vim /etc/config/system找到config system在下面添加即可1234567config system option hostname 'OpenWrt' option conloglevel '8' option cronloglevel '8' option log_ip '192.168.1.247' option log_port '514' option log_size '200' 然后保存并应用，过一会就可以在本机上看到路由上的log了 处理问题上面说了一大堆log的配置，最终的目的只是方便分析日志．而我们分析日志就是为了解决问题的．．．分析日志：发现有很多的这种信息daemon.warn odhcpd[903]: A default route is present but there is no public prefix on br-lan thus we don&#39;t announce a default route!这个是因为开启了IPv6的原因，我们用不上，关掉即可 总结我感觉问题不太可能是出现在IPv6上面的，虽然我关掉后确实断线的情况好了很多．．通过这次鼓捣，让我又对OpenWrt熟悉了不少，当然最大的收获还是rsyslog了，之前虽然知道有这么个东西，但一直没有机会去用上它，配置过一次后感觉以后就熟悉多了．","tags":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://lusyoe.github.io/tags/OpenWrt/"},{"name":"Log","slug":"Log","permalink":"https://lusyoe.github.io/tags/Log/"}]},{"title":"OpenWrt之初相识篇","date":"2016-06-04T15:47:34.000Z","path":"2016/06/04/OpenWrt之初相识篇/","text":"最早是在几年前就知道了OpenWrt的，当时只是为了”翻墙”更方便点，才搜到这个东西的．．然而无奈能力有限，一直没法去把玩尝试它．去年刚好我哥买了一个很便宜的路由器，用不上就给我了．我想着这个反正弄坏了也没太大关系，就又去网上找各种资料了，什么不死uboot啦，什么高科固件一大堆的． 总之折腾了好几天终于是弄好了.看这高大上的界面，简直要甩原厂自带那个丑爆的界面好几条街．功能更是没法比．． 最让人兴奋的就是可以装各种第三方的软件了，其中就包含Shadowsocks翻墙工具，我最初的目的也就是这个了．作为一个技术人员，不能google查找资料，就算是不称职的啦．政治这种东西我们不关心，但是技术文档和问题解决方案这些却是必不可少的了．","tags":[{"name":"OpenWrt","slug":"OpenWrt","permalink":"https://lusyoe.github.io/tags/OpenWrt/"}]},{"title":"Linux软件篇之Docker","date":"2016-03-09T14:49:05.000Z","path":"2016/03/09/Linux软件篇之Docker/","text":"我是在2014年就开始接触docker的，那时候docker刚刚火起来，最开始只是把它当做是虚拟机的一种替代品吧，而且启动速度快，消耗的硬件资源也没一般虚拟机那么大，可以说是跟主机共享使用资源的，不像虚拟机，要一开始就固定的进行分配。。 在2015年的时候，我就开始尝试着在工作中使用它了。那时候刚做android系统开发，被那个编译环境搭建搞的欲死欲活的，就想有什么方法可以一键搭建哦。然后当时公司服务器都使用的是centos，但android编译环境可要求的是Ubuntu呀，没办法就想到了虚拟化。最后就又想到Docker了，在网上找了找，果然已经有国外的大神写好了针对CyanogenMod的dockerfile环境搭建了。拉下来一键就部署好了。 下面记录一下当时使用的笔记吧。 Ubuntu修改Docker服务启动默认数据文件存放位置默认Docker将数据文件都放在/var/lib/docker中，如果该分区不是很大的话，不利于后期的扩展，尤其是作为android源码项目来说的，因此可修改配置文件，使其数据存储路径指定在其他位置。 Upstart方式：编辑/etc/default/docker ，添加DOCKER_OPTS=&quot;-g /opt/docker&quot; 即可改到/opt/docker路径中。 Systemd方式：","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://lusyoe.github.io/tags/Docker/"}]},{"title":"Linux软件篇之systemd","date":"2016-03-08T15:32:00.000Z","path":"2016/03/08/Linux软件篇之systemd/","text":"简介systemd是Linux下一种init软件，主要是用来管理系统服务的，当然了systemd不仅仅是可以管理系统服务，还有日志管理、系统资源管理等等，systemd可以说是非常强大也非常复杂的一种软件。 系统服务管理 激活开机启动服务 $ sudo systemctl enable [service-name] 取消开机启动服务 $ sudo systemctl disable [service-name] 查看是否开机启动服务 $ systemctl is-enable [service-name] 查看开机每个服务消耗的时间 $ systemd-analyze blame 查看开机消耗总时间 $ systemd-analyze 查看所有被激活的服务 $ systemctl list-units -t service 查看一个服务的状态 $ systemctl status [service-name] 启动、停止、重启一个服务 $ sudo systemctl start(stop、restart) [service-name] 重新加载一个服务(可以只加载服务的配置文件而不重启服务) $ sudo systemctl reload [service-name] 日志管理 查看启动日志(默认只保存本次启动的日志) $ sudo journalctl 查看某个服务的日志 $ sudo journalctl [service-path](如：/usr/sbin/sshd) 查看实时日志 $ sudo journalctl -f 重新载入systemd所有更改的配置，扫描新的或变动的单元 $ sudo systemctl daemon-reload 查看内核日志(不显示应用日志) $ sudo journalctl -k 查看某个路径的脚本的日志 $ sudo journalctl /bin/bash 显示日志占据的硬盘空间 $ sudo journalctl --disk-usage 以上都为常用的功能，当然还有需要添加自定义的服务，这个以后再说。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"},{"name":"Systemd","slug":"Systemd","permalink":"https://lusyoe.github.io/tags/Systemd/"}]},{"title":"Linux软件篇之tmux","date":"2016-03-07T10:31:24.000Z","path":"2016/03/07/Linux软件篇之tmux/","text":"tmux 是一款优秀的终端复用软件，它通过前缀键+操作键进行使用。tmux前缀键默认为Ctrl+b，可通过配置文件进行更改，后面会写到。tmux 分为会话(Session)、窗口(Window)和窗格(pane)。 快捷键会话(Session) 创建一个新的Session$ tmux new -s &quot;名称&quot; 在tmux中再创建一个SessionCtrl+b :new -s &quot;名称&quot; 切换不同的SessionCtrl+b s up(down)方向键 重命名当前SessionCtrl+b $ 退出当前Session$ exit 恢复最上面的一个Session$ tmux a 恢复指定Session$ tmux attach-session -t &lt;session-name&gt; 窗口(Window) 创建一个新的WindowCtrl+b c 重命名当前WindowCtrl+b , 创建一个指定名字的WindowCtrl+b :new-window -n &lt;window-name&gt; 切换不同的WindowCtrl+b number(位于window名字:前面的数字编号) 删除当前的WindowCtrl+b &amp; 窗格(Pane) 垂直分割窗口(一左一右2个窗格)Ctrl+b % 水平分割窗口(一上一下2个窗格)Ctrl+b &quot; 切换不同的窗格(Pane)Ctrl+b up(down、left、right上下左右方向键) 删除当前的窗格(Pane)Ctrl+b x 复制、粘贴文本 Ctrl+b [ 进入复制模式 Space 空格键开始复制指定的文本(类似vi的可视模式) Enter 回车，复制完成 Ctrl+b ] 粘贴文本 配置编辑~/.tmux.conf文件 修改前缀键为Ctrl+a(C-a)set -g prefix C-a 解除原来的Ctrl+bunbind C-b 其他的配置和快捷键可通过$ man tmux查看tmux的手册 总结一下我使用tmux最主要的还是看中它的现场恢复了。比如说：今天在服务器上进行编码修改，快到下班时间，不想等着加班搞完了再回去，可以直接关掉电脑走人，第二天来登陆服务器，直接$ tmux a即可完美回到前一天正在修改的地方，继续接着改就可以了。不然每次下班第二天来又要找半天前一天要改的地方了。。还有一个好处是tmux只通过一个ssh连接就可以实现多个终端操作了，大家都知道在工作中，一个终端的使用是远远不够的，如果不用类似tmux这样的软件，就必须要进行多次ssh连接了。最后需要注意一下的是: 使用tmux恢复时，必须要保证在上一次断开连接到这次恢复之间，服务器(主机)不能重启，一旦重启了就什么都没了。。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"}]},{"title":"Linux软件篇之ssh","date":"2016-03-06T08:16:57.000Z","path":"2016/03/06/Linux软件篇之ssh/","text":"ssh 可以说是最常用的一个远程登陆服务器进行控制的软件了，总结一下。一般的Linux发行版都自带了ssh客户端，如果需要安装服务端的话，执行1$ sudo apt-get install openssh-server 生成公私密钥 本机$ ssh-keygen 指定$ ssh-keygen -t rsa -C &quot;xxx@xx.com&quot; 无需密码登陆服务器 将公钥(一般位于~/.ssh/id_rsa.pub)内容，存放到远程服务器指定账户的Home目录下面的~/.ssh/authorized_keys中,如果没有authorized_keys文件的话就新键一个。在这里有一个很方便的命令可以直接使用：$ ssh-copy-id 服务器用户名@域名或ip下次登陆服务器就无需再次输入密码了,登陆命令：$ ssh username@addr 快速连接通过config配置文件，可无需每次都输入远程用户名和地址即可进行连接。在~/.ssh下新建config文件，编辑添加内容如下：1234Host testHostName xxx.xxx.xxx.xxx(远程服务器ip)User root(登陆远程的用户名)Port 22(登陆的端口) 之后连接直接使用：$ ssh test即可 远程与本地传输文件通过scp命令进行本地与远程之间的数据传递. 从远程主机拷贝到本地$ scp 远程user@addr:文件路径(默认用户home目录) 本地路径(同上) 将本地文件拷贝到远程主机$ scp 本地文件路径 远程user@addr:文件路径(默认用户home目录) 拷贝目录(递归)$ scp -r","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"}]},{"title":"Linux软件篇","date":"2016-03-06T07:27:58.000Z","path":"2016/03/06/Linux软件篇/","text":"总结一下，在Linux下使用过的一些软件，不包括开发使用的 axel 终端下载器可通过 -n x(数字) 设置下载时使用的线程数 ,如：1$ axel -n 5 &lt;URL&gt; 新立得包依赖管理器 synaptic虽然一般直接使用apt-get的比较多，不过在处理依赖方面，这个软件还是挺强大的 查找库文件以及对应包的神器apt-file第一次安装成功后，需要更新数据库$ apt-file update查找包信息或库文件所在包$ apt-file search xxx 文件编码转换iconv，一般情况下使用方法：$ iconv -f 原来编码 -t 新编码 文件名 词典goldendict 文本比较工具Meld Diff Mac 托盘效果Cairo-dock 可视化系统管理面板(web端)ajenti 网络端口流量监控iftop 截图工具shutter markdown可视化工具remarkable tty显示中文fbterm 摄像头软件Camorama 笔记本数字小键盘工具numlockx 激活小键盘 numlockx on 禁用小键盘 numlockx off 基于终端的文件浏览器ranger","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"}]},{"title":"Ubuntu基础操作","date":"2016-03-06T06:57:42.000Z","path":"2016/03/06/Ubuntu基础操作/","text":"将早期学习Linux的一些笔记整理下 安装中文man手册1$ sudo apt-get install manpages-zh 查看系统发行版本1$ lsb_release -a 查看内核版本1$ uname -a 历史命令 查看已记录的所有历史命令$ history 执行指定编号的历史命令$ !N N为命令前面的编号 修改历史命令，然后退出时执行 $ fc N 开机自动执行命令编辑/etc/rc.local文件，在exit 0前面添加命令即可 新装系统，切换root失败首次安装好系统后，root用户没有设置默认密码，因此执行su命令会报错设置root密码1$ sudo passwd root","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lusyoe.github.io/tags/Ubuntu/"}]},{"title":"Hello World","date":"2016-03-05T05:14:52.000Z","path":"2016/03/05/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]