[{"title":"MySQL视图之理论篇","date":"2016-08-29T15:15:05.000Z","path":"2016/08/29/MySQL视图之理论篇/","text":"","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lusyoe.github.io/tags/MySQL/"}]},{"title":"Gitlab CI Multi Runner搭建CI持续集成环境","date":"2016-08-29T12:32:56.000Z","path":"2016/08/29/Gitlab-CI-Multi-Runner搭建CI持续集成环境/","text":"GitLab不仅仅只是代码托管的工具，它还集成了CI的功能，通过Gitlab CI Multi Runner工具可以更方便的搭建持续集成环境。在安装好GitLab之后还需要再安装一个叫gitlab-ci-multi-runner的工具。PS: 当然了肯定没有Jenkins那么强大，毕竟可用插件太多了。 安装gitlab-ci-multi-runner 官方多种安装方式由于众所周知(墙)的原因，还是推荐Gitlab CI Multi Runner 清华镜像 gitlab-runner命令介绍服务状态安装好runner之后就可以使用gitlab-runner命令了，可通过# gitlab-runner help查看命令帮助，更多命令详情可以查阅官方文档好了，让我们来先查看一下服务运行的状态。# gitlab-runner status输出以下内容，说明服务运行正常了。gitlab-runner: Service is running! 还有也可以通过以下命令查看，不过我更喜欢短一点的命令，后面都只使用gitlab-runner了。# gitlab-ci-multi-runner status 注册一个runner注册一个runner可以使用交互式和非交互式两种方式，默认使用交互式的。输入以下命令就可以开始交互式注册了，在这之前请确保Gitlab上面已经新建有项目了。# gitlab-runner register 123456789101112131415Running in system-mode.Please enter the gitlab-ci coordinator URL (e.g. https://gitlab.com/ci):http://192.168.1.2/ci // 在这里输入gitlab安装的服务器ip/ci 即可Please enter the gitlab-ci token for this runner:eaYyokc57xxZbzAsoshT // 这里的token可通过Gitlab上的项目Runners选项查看，在下面贴一张截图Please enter the gitlab-ci description for this runner:[E5]: spring-demo // 这里填写一个描述信息，不太重要，看着填吧Please enter the gitlab-ci tags for this runner (comma separated):demo // 在这里填写tag信息，多个tag可通过逗号,分割。Registering runner... succeeded runner=eaYyokc5Please enter the executor: docker, docker-ssh, parallels, shell, ssh, virtualbox, docker+machine, docker-ssh+machine:shell // 在这里需要输入runner的执行方式，因为我的Gitlab和runner是安装在同一台服务器上的，直接输入shellRunner registered successfully. Feel free to start it, but if it&apos;s running already the config should be automatically reloaded!// 出现这样信息表示服务端的配置就已经成功结束了，如果需要使用到自动构建，还需要再添加一个配置文件，下面说说这个。 查看runner配置信息可通过以下命令进行查看# gitlab-runner list12Listing configured runners ConfigFile=/etc/gitlab-runner/config.tomlspring-demo Executor=shell Token=387ed6c05fef248d2183f9f45b9cda URL=http://192.168.1.2/ci 也可以直接打开配置文件进行查看# vim /etc/gitlab-runner/config.toml123456789101112131415161718192021concurrent = 1check_interval = 0[[runners]] name = \"spring-demo\" url = \"http://192.168.1.2/ci\" token = \"387ed6c05fef248d2183f9f45b9cda\" executor = \"shell\" [runners.ssh] [runners.docker] tls_verify = false image = \"\" privileged = false disable_cache = false [runners.parallels] base_name = \"\" disable_snapshots = false [runners.virtualbox] base_name = \"\" disable_snapshots = false [runners.cache] 删除注册信息如果发现register信息填写错误，或者不再使用了。可通过以下命令进行删除。 首先查看已注册过的信息# gitlab-runner list 12Listing configured runners ConfigFile=/etc/gitlab-runner/config.tomlspring-demo Executor=shell Token=387ed6c05fef248d2183f9f45b9cda URL=http://192.168.1.2/ci 开始删除# gitlab-runner unregister --url http://192.168.1.2/ci --token 387ed6c05fef248d2183f9f45b9cda其中–url参数可查看上面的URL=后面的值填写，–token参数就是上面的Token=后面的值，复制粘贴即可。 123Running in system-mode.Deleting runner... succeeded runner=387ed6c0 出现上面信息表示删除成功了。注意：这个操作是不可逆的，为了防止出错可以先备份一下/etc/gitlab-runner/config.toml配置文件 项目自动化构建配置配置好了runner，想要开始自动构建还需要在项目根目录添加一个.gitlab-ci.yaml文件。关于.gitlab-ci.yaml文件的配置说明可参考官方文档。下面贴一下我做测试Demo时使用的，不要笑，很简单只做演示用的。。.gitlab-ci.yaml123456789stages: - build - deployjob1: stage: build script: &quot;mvn package&quot;job2: stage: deploy script: &quot;mvn tomcat:redeploy -Dmaven.test.skip=truey -e -X&quot; 总结到这里关于CI持续集成的差不多就说那么多了，当然了还有很多都没说到，这就要看实际的项目需求进行相应的配置了。总的来说呢，gitlab-runner虽然跟Gitlab集成的比较好，但是功能方面还是有点不如老牌的Jenkins。不过它对Docker倒是支持的蛮好的，说起来我接触Docker也是挺早的了，它2013年开源，我2014年就开始接触了，并且2015年也在公司服务器上实际部署了，后面有时间再写点关于Docker的吧。不过跳槽后就用的少了，但愿别都忘了好:)。","tags":[{"name":"CI持续集成","slug":"CI持续集成","permalink":"https://lusyoe.github.io/tags/CI持续集成/"}]},{"title":"Jenkins+Gitlab搭建CI持续集成架构","date":"2016-08-28T12:54:20.000Z","path":"2016/08/28/Jenkins-Gitlab搭建CI持续集成架构/","text":"首先安装Jenkins和Gitlab很简单就不多说了，贴个地址Installing JenkinsInstall a GitLab CE需要注意的是，在中国大陆由于墙的问题，Gitlab下载非常的慢，有可能导致下载失败了。。在这里推荐一下清华大学镜像源，在国内速度杠杠的。Gitlab Community Edition 镜像使用帮助有兴趣的可以看看它们的镜像首页，目前支持的镜像挺多的，而且还在不断的增加呢。 安装Jenkins插件做持续集成，Jenkins默认安装后还需要再安装一些插件。安装插件很简单，通过浏览器进入安装好Jenkins的服务器首页——&gt;点击系统管理——&gt;管理插件——&gt;可选插件然后过滤查找以下插件，勾选安装即可 Git client plugin Git plugin Gitlab Hook Plugin 创建代码仓库添加Webhooks好了，让我们来开始实际操作吧先在Gitlab上创建一个仓库，然后在项目的设置中选择Webhooks，在URL上填http://[jenkins-ip]:8080/gitlab/build_now前面是jenkins服务器的IP,端口号默认是8080，如果服务器上有类似tomcat这样的程序占用端口，就需要更改端口号了，这里也就要相应的修改了。还有一种情况，如果是通过Jenkins官网下载的war包形式，这里的URL就要改为http://[jenkins-ip]:8080/jenkins/gitlab/build_now 创建Jenkins项目进入我们服务器的Jenkins首页——&gt;点击新建——&gt;输入一个项目名称——&gt;选择构建一个自由风格的软件项目(free-style)点击ok进入了项目配置页面，然后按以下步骤操作就好了 源码管理设置，选中Git，把刚刚从Gitlab上创建的项目地址复制过来，在这里推荐使用http的形式，避免因为权限的问题导致代码无法pull下来。 构建设置，继续往下拖看到构建选项，点击增加构建步骤，可以根据具体项目来选择，在这里以Web的Maven项目为例。选择Invoke top-level Maven targets，Maven Version可根据个人选择，如果要添加自己下载的版本，可在首页——&gt;系统管理——&gt;Global Tool Configuration全局工具配置下面找到Maven进行添加。推荐使用自己的Golas框中填写maven的执行命令，比如： 12packagetomcat:redeploy -Dmaven.test.skip=true -e -X 之后保存应用即可注意：这里不需要添加mvn命令，jenkins会自动帮我们添加的，还有每一个命令占单独一行。 自动化构建好了，基本上都配置完了，现在该我们编写程序代码了。只需要从Gitlab上把源码pull到本地，然后进行coding修改再push上去即可。Jenkins那边会监听到push的操作后就自动pull下载更新代码然后进行相应的构建部署了。进入到Jenkins项目，可以查看到构建历史下面正在构建的项目，点击项目编号，再点击Console Output控制台输出就可以查看构建过程的详细日志了。 总结当然了持续集成肯定没这么简单的，后面应该还要有自动Test测试，导出报告之类的。在这里只是搭建一个最基本最简单的持续集成框架。","tags":[{"name":"CI持续集成","slug":"CI持续集成","permalink":"https://lusyoe.github.io/tags/CI持续集成/"}]},{"title":"MySQL基础之索引实战篇","date":"2016-08-21T13:29:38.000Z","path":"2016/08/21/MySQL基础之索引实战篇/","text":"在上一篇已经较为全面的讲述了索引的理论，现在进行实战操作。 在这里只列出常用索引类型的操作，关于更多的索引分类参看MySQL基础之索引理论篇 索引的创建 创建表的时候创建索引普通索引123456CREATE TABLE IF NOT EXISTS book( bookid INT NOT NULL, year_pub YEAR NOT NULL, INDEX(year_pub)); 上面语句是在year_pub字段上创建索引的 唯一索引唯一索引只是多加了一个UNIQUE关键字，以下语句为在id字段上添加唯一索引并命名为UniqIdx123456CREATE TABLE IF NOT EXISTS perso( id INT NOT NULL, name CHAR(30) NOT NULL, UNIQUE INDEX UniqIdx(id)); 组合索引12345678CREATE TABLE IF NOT EXISTS employee( id INT NOT NULL, name CHAR(30) NOT NULL, age INT NOT NULL, info VARCHAR(255), INDEX MultiIdx(id, name, age)); 全文索引FULLTEXT全文索引可以用于全文搜索，但只有MyISAM存储引擎才支持，并且必须为CHAR、VARCHAR、TEXT列。 12345678CREATE TABLE person( id INT NOT NULL, name CHAR(30) NOT NULL, age INT NOT NULL, info VARCHAR(255), FULLTEXT INDEX FullTextIdx(info))ENGINE=MyISAM; 通过SHOW CREATE TABLE person;可查看创建表的过程。 在已经存在的表上创建索引主要是通过ALTER TABLE 和 CREATE INDEX 语句进行的，推荐使用CREATE INDEX 普通索引在perso表的name上建立名为PoNameIdx的普通索引 123ALTER TABLE perso ADD INDEX PoNameIdx(name(30));或者CREATE INDEX PoNameIdx ON perso(name(30)); 通过SHOW INDEX FROM perso;命令可以查看perso表当前的所有索引信息。 唯一索引123ALTER TABLE person ADD UNIQUE INDEX UniqNameIdx(name(30));或者CREATE UNIQUE INDEX UniqNameIdx ON person(name(30)); 组合索引123ALTER TABLE person ADD INDEX PoAgeAndInfo(age, info);或者CREATE INDEX PoAgeAndInfo ON person(age, info); 全文索引在这里需要注意，全文索引只能在存储引擎为MyISAM的表上使用。123ALTER TABLE person ADD FULLTEXT INDEX infoFTIdx(info);或者CREATE FULLTEXT INDEX infoFTIdx ON person(info); 如果该字段上已经存在了索引，可以先删除掉，然后再创建。 索引的删除相较于索引的创建，删除索引的操作就比较简单很多了。 ALTER TABLE删除索引遵循以下基本语法格式即可：ALTER TABLE table_name DROP INDEX index_name如：1ALTER TABLE person DROP INDEX infoFTIdx; DROP INDEX删除索引格式如下：DROP INDEX index_name ON table_name如： 1DROP INDEX PoNameIdx ON perso; 结语最后索引的实战大概就写这么多吧，这些都只是基本操作。实际开发中重点应该是如何选择索引。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lusyoe.github.io/tags/MySQL/"}]},{"title":"MySQL基础之索引理论篇","date":"2016-08-21T12:19:23.000Z","path":"2016/08/21/MySQL基础之索引理论篇/","text":"简介索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可极大提高数据库查询的速度。 索引的含义和特点索引是一个单独的、存储在磁盘上的数据库接口，它们包含着对数据表里索引记录的引用指针。使用索引用于快速找出在某个或多个列中有一特定的行，所有MySQL列类型都可以被所有，对于相关列使用索引是提高查询操作速度的最佳途径。 由于索引是在存储引擎中实现的，因此采用不同的存储引擎的表支持的索引类型也不相同。MySQL中索引的存储类型有两种：BTREE和HASH，具体和表的存储引擎相关的是：MyISAM和InnoDB存储引擎只支持BTREE索引；MEMORY/HEAP存储引擎可以支持HASH和BTREE索引。 索引的优点 通过创建唯一索引，可以保证数据库表中每一行数据的唯一性。 可以大大加快数据的查询速度，这也是创建索引的最主要的原因。 在实现数据的参考完整性方面，可以加速表和表之间的连接。 在使用分组和排序子句进行数据查询时，也可以显著的减少查询中分组和排序的时间。 索引的缺点 创建索引和维护索引要耗费时间，并且随着数据量的增加所耗费的时间也会增加。 索引需要占磁盘空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果有大量的索引，索引文件可能比数据文件更快达到最大文件大小。 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引的分类MySQL的索引可以分为以下几类： 普通索引和唯一索引 普通索引是MySQL中的基本索引类型，允许在定义索引的列中插入重复值和空值。 唯一索引，索引列的值必须唯一，但允许有空值。如果是组合索引，则列值的组合必须唯一， 主键索引是一种特殊的唯一索引，不允许有空值。 单列索引和组合索引 单列索引即一个索引只包含单个列，一个表可以有多个单列索引。 组合索引指在表的多个字段组合上创建的索引，只有在查询条件中使用了这些字段的左边字段时， 索引才会被使用。使用组合索引时遵循最左前缀集合。 全文索引 全文索引类型为FULLTEXT，在定义索引的列上支持值的全文查找，允许在这些索引列中 插入重复值和空值。全文索引可以在CHAR、VARCHAR或者TEXT类型的列上创建。 MySQL中只有MyISAM存储引擎支持全文索引。 空间索引 空间索引是对空间数据类型的字段建立的索引，MySQL中空间数据类型有4种， 分别是：GEOMETRY、POINT、LINESTRING和POLYGON。MySQL使用SPATIAL关键字进行扩展， 使得能够用于创建正规索引类似的语法创建空间索引。创建空间索引的列，必须将其声明为NOT NULL， 最后空间索引只能在存储引擎为MyISAM的表中创建。 索引的设计原则 索引设计不合理或者缺少索引都会对数据库和应用程序的性能造成障碍。高效的索引对于获得良好的性能非常重要。 设计索引时，应该考虑以下准则： 索引并非越多越好，一个表如有大量的索引，不仅占用磁盘空间，而且会影响INSERT、DELETE、UPDATE等语句的性能，因为当表中的数据更改的同时，索引也会进行调整和更新。 避免对经常更新的表进行过多的索引，并且索引中的列尽可能少，而对经常用于查询的字段应该创建索引，但要避免添加不必要的字段。 数据量小的表最好不要使用索引，由于数据较少，查询花费的时间可能比遍历索引的时间还要短，索引可能不会产生优化效果。 在条件表达式中经常用到的不同值较多的列上建立索引，在不同值少的列上不要建立索引。比如在用户表的”性别”字段上只有”男”与”女”两个不同值，因此就无须建立索引。如果建立索引不但不会提高查询效率，反而会严重降低更新速度。 当唯一性是某种数据本身的特征时，指定唯一索引。使用唯一索引需能确保定义的列的数据完整性，以提高查询速度。 在频繁进行排序或分组(即进行group by或order by操作)的列上建立索引，如果待排序的列有多个，可以在这些列上建立组合索引。","tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://lusyoe.github.io/tags/MySQL/"}]},{"title":"Idea Maven项目无法下载依赖问题汇总","date":"2016-08-21T11:31:50.000Z","path":"2016/08/21/Idea-Maven项目无法下载依赖问题汇总/","text":"在使用IntelliJ IDEA开发Web的时候，刚开始总是遇到Maven的各种问题。现在总结一下关于无法下载依赖jar的问题。 依赖语法错误 有时候没注意，直接就这样写了：12345&lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt; 然而，像这种单个的依赖必须要添加到&lt;dependencies&gt;&lt;/dependencies&gt;中间才行。正确的做法应该是这样:1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;3.1.0&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 可恨的是IDE也不提示个什么。。 配置问题如果在pom.xml文件中packageing属性配置不对也不会下载依赖的。比如说：1&lt;packaging&gt;war&lt;/packaging&gt; 当配置为war的时候就不允许下载了，必须要为pom才行。这个IDE又是不提示，还是我手动敲命令才发现的：1$ mvn compile 执行上面命令就会提示了：&#39;packaging&#39; with value &#39;war&#39; is invalid. Aggregator projects require &#39;pom&#39; as packaging. 所以当在开发初期的时候要改为：1&lt;packaging&gt;pom&lt;/packaging&gt;","tags":[{"name":"Maven","slug":"Maven","permalink":"https://lusyoe.github.io/tags/Maven/"}]},{"title":"回首感悟","date":"2016-08-20T13:42:22.000Z","path":"2016/08/20/回首感悟/","text":"人生总是充满着选择，每一个选择又会造成截然不同的结果。从13年毕业至今，感觉人生真的是变化很快啊。毕业后，毅然决然的选择了转行，到现在也算是差不多完全融入IT这一行了。很庆幸，当初并没有选择错误。虽然不是科班出身，但凭着一股浓厚的兴趣，能真正入行也是不容易了。 回首一下这3年 2013年6月正式毕业了和绝大多数人一样，我毕业后一段时间都是很茫然的状态，不知道到底要做什么，毕竟刚踏入社会，什么都不了解。我选择了回家，由于在毕业之前报考了学校的计算机二级考试，开始在家里自学计算机课程了，编程语言当然只有C了。经过了暑期的几个月学习，最终顺利的考过了，也算是给自己增加了不少信心吧。不过就这样想找工作还是早得很啊。。 2013年9月-12月 Java起航之后又开始自学Java了，当初学Java完全就是奔着Android去的，那时候Android太火了。学Java的过程中又报了计算机网络自考本科，开始全面系统的学习计算机课程了。 2014年3月-6月 自考之路2014年可以说是最重要的一年了，由于基础底子太差了，仅仅凭着几个月的学习完全赶不上来。当然了，自考可以说是一败涂地了，几次过后就已经完全放弃了。。在这期间最大的收获就是在武大表哥那里的生活了，完全可以说是表哥带着我从毕业后的迷茫期走出来的。让我真正的建立了一个成年人的思想，有了自己的思想和主见。那段时间思考的最多的就是人生了。我的人生到底要怎么走，自考的失败可以说差点让我放弃了走IT的路了，那段时间整个人也是懵的。也是表哥把我拉出来的，真的是要非常的感谢他了。 2014年7月-8月 初次踏入社会2014年的暑期，第一次走入社会寻找工作了，虽然之前在校的时候有过实习经验，但那是建筑行业的了。既然已经打算换行了，当然不想再找那方面的工作了。然而，现实就是这么的残酷，就我这水平什么都找不到。。 无奈只能找一些工厂先去锻炼下了在武汉，去过富士康，由于大专的毕业，居然不要。。好像那些小学毕业的才更吃香啊接连的找了好几个厂子，最后还是在人才市场，找到了一个愿意收我的小厂了。走入工厂才知道那有多么的辛苦啊，每天都是机械性的劳动，还有白班夜班的倒。。 结果自然不言而喻，在那里只做了一周，还是放弃不下计算机编程啊 2014年9月-12月 培训之旅在武汉，在网上搜一些计算机实习工作时，发现了培训机构。当然了咱好歹也是成年人了，肯定不会被他们所忽悠，什么包就业，推荐工作啥的，一个字都不会信。但是知识这东西，恰好是我目前最缺乏的，通过网上用人单位的招聘需求，很多东西也不懂。这方面培训机构还是很有经验的，通过到多个培训机构试听，最终还是选择了一个看起来靠谱点的。 培训内容主要为：Java基础、Web入门和Android就业Java基础由于之前有过自学，所以还是挺轻松的，几次测验基本在班里也是第一的Web入门：当时对Web没有太过关注，也就真的只是入个门啦，当然那个讲师还是挺有水平的最关键是Android了，当时真的是挺用心的了，基本上白天学完了，晚上继续敲代码到凌晨1,2点 时间就这样在充实的学习过程中过去了. 2015年2月-3月 工作工作培训终于结束了，也算是给我开启了一扇IT的大门吧，经过培训过后，我才感觉已经踏入IT门槛了。2015年2月过完年后，为了发展到深圳来了。刚开始找工作，真的觉得自己还是太嫩了，以至于快1个月才终于找到了一个像样的工作了。当然了，这里还有个小插曲，需要感谢一下当初的培训机构。为了找工作，像我这种出身的，简历当然得要伪造了(惭愧)，不然不用想了。。。新单位居然要打电话给之前的单位调查背景，幸好我当初保存了培训机构的前台号码。 2015年3月-2016年1月 Android实战终于终于我找到一份Android开发的工作了，虽然是面向Android TV端的…突然发现自己不会的还是有好多啊，压力有点大。但是日子总得过啊 每天下了班后回来继续看项目学习了，可怜原还以为能有个人带带呢，结果就我1个Android开发。 碰碰磕磕，差不多一年的时间就这样过去了，也差不多熟悉Android app的基本开发了。 在这期间由于意外情况，接触到了Android系统底层的东西了，比如：自己编译ROM刷到盒子里面，静默安装等等 也跟一些厂商有打过交道了，比如：深圳的兆驰、TCL、小霸王等第一次听说了，除了MTK，高通之外的芯片了，如：Amlogic、Rockchip第一次听说并使用了Docker第一次自己去制作.9 图第一次把自己学习到的东西都运用上了等等… 2016年2月-3月 Android系统由于种种原因，不得不从这家辞职了。是该考虑下一家的时候了。打算好了去南山发展，毕竟在深圳南山区才是IT科技氛围最浓厚的区域了。刚开始也找了好几家app的开发，不过貌似大部分都对我有系统开发经验有兴趣点，那我是该考虑一下方向了，毕竟相对于app来说，我对系统底层也是更有兴趣一点(讨厌UI)。。 最终在科技园附近找到了一家偏系统开发的工作了，我也没想到人生第一次薪水过万会来的如此之快。 刚入职肯定是要好好表现了，发现他们居然连版本控制工具都没用，文件都是copy来copy去的。咱现在也不是那种刚入行的嫩鸟了，而且对于系统源码来说，没有版本控制实在是太容易出错了。 由于之前在上一家的学习，知道了怎么搭建一整套源码管理。耗费一周的时间，成功的搭建起了gitlab + repo + git的源码管理系统。gitlab作为最上层的操作界面，项目组每个人接触最多的东西repo 来着google官方的Android系统源码管理工具，可以管理许多的git小仓库git 最底层当然是使用git了，最流行最适合最好的系统源码管理工具了 然而git毕竟学习成本较高啊，在我走之后他们就没法使用了。。。 2016年3月-至今 正式Android Framework Engineer是的，我只在上一家待一个月就跳槽走了，原因说起来很可笑，有时候星期六要加班，而且还是免费的…我不喜欢这样，虽然都说在IT这行加班是很普遍的，但是那也是要有相应的补贴才行啊。免费的工，抱歉我不会打。 经过了一周的找工作面试，最终我却选择了外包公司。整个行业都在说外包怎么怎么的坑，当然了不排除确实有那么一些。 但是这家能给出比我上一家还要多出50%的薪水，我没理由不去啊。入职之后就是直接到某手机厂商那上班了，是说长期驻场来着。跟他们的员工一样的工作上班等在这里加班还是挺少的，待遇也不错，真的很满意了 发现了外包也有不错啊，很多东西光只听别人说真的很容易造成误导。小时候都听说过小马过河故事呢 还有就是在大公司就是不一样，流程非常的严谨，整个的开发流程就跟我之前所经历的完全不一样。第一次见识到了code review、自动化Test等各种流程了，感觉学到了很多。 在这里我也被分配到了framework组，做一些中间层功能接口开发、移植和Bug的修复等工作 然而，时间过去我发现自己没有了对Android的热爱，少了当初的那一份激情了。在这个暑期，我又对Java大数据，分布式感兴趣了起来。不，应该说我始终对编程有着热爱，但是现在每天却很少coding了，而Android即使是app项目的代码量也不大。并没有充分的展现出现编程的艺术来。是的，编程不仅仅是一种技术，更应该是一种艺术。 话说，今年看书还是看的挺多的，光这个暑期就看完3本了《Head First 设计模式》、《MySQL 5.5》、《分布式Java应用》可以看到，基本都是为下一步做的技术储备了，相比上半年看的《深入理解Android》系列等Android系统开发方面书籍确实变化蛮大的。 我想我已经做好了选择，不管以后的结果如何，选择了就不会后悔~","tags":[{"name":"感悟总结","slug":"感悟总结","permalink":"https://lusyoe.github.io/tags/感悟总结/"}]},{"title":"Jenkins新建Maven项目构建出现mvn command execution faild","date":"2016-08-09T22:49:44.000Z","path":"2016/08/10/Jenkins新建Maven项目构建出现mvn-command-execution-faild/","text":"第一次用Jenkins作持续集成自动化构建，难免经验不足。安装好，一来就直接新建一个Maven任务，然后就立即构建了，结果控制台总是输出123FATAL: command execution failedjava.io.IOException: Cannot run program \"mvn\" (in directory).... 百度google，无果。最终发现了原来是Jenkins工具里没有配置Maven… 回到Jenkis主目录，点击左边的系统管理 点击全局工具配置(Global Tool Configuration) 拖到最下面发现有一个Maven项目，点击新增Maven,默认可以选择在线自动下载安装，如果本地已经安装了的话，可以去掉自动安装,输入安装的根路径。 最后保存应用一下，再尝试build，果然成功了^_^","tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://lusyoe.github.io/tags/Jenkins/"}]},{"title":"Shadowsocks日志中failed to recv data in handshakeReceive2Callback的错误解决办法","date":"2016-07-27T15:12:30.000Z","path":"2016/07/27/Shadowsocks日志中failed-to-recv-data-in-handshakeReceive2Callback的错误解决办法/","text":"最近重装了一下Win7系统，装好常用软件后，突然发现上google的时候shadowsocks不能用了，但是在Linux下用的好好的，刚开始还以为是系统的问题，差点就再重装了。最后通过log日志分析，然后再通过VPN进行goole搜索(百度基本搜不到什么有效信息)，找到了胡大伟的官方网站的这篇blog，刚好解决了问题。:)123Win+r services.msc打开服务管理窗口在里面找到xlserviceplatform把这个服务禁用了。找到C:\\Program Files(x86)\\Common Files\\Thunder Network\\ServicePlatform\\XLSP.dll文件删除之即可 幕后真凶原来是迅雷，对国内这些东西已经是彻底无语了。 在这里感谢下胡大伟!","tags":[{"name":"shadowsocks","slug":"shadowsocks","permalink":"https://lusyoe.github.io/tags/shadowsocks/"}]},{"title":"OpenWrt之Log篇","date":"2016-06-04T15:50:16.000Z","path":"2016/06/04/OpenWrt之Log篇/","text":"目录 简介 logread 上传到远程rsyslog服务器 配置rsyslog 处理问题 总结 简介我接触OpenWrt也不长，之所以关注log这个东西，主要是前段时间路由器总是断线，所以想要分析一下原因． logread在OpenWrt中可通过logread命令查看运行时的log日志，我一般都是通过ssh进行远程访问路由器的．不过每次查看log，都要登陆进去，然后不断的敲logread也是很麻烦的，正好OpenWrt的web设置界面中有设置上传日志的选项，在我这是 系统—&gt;日志里面 上传到远程rsyslog服务器由于之前每次看日志都不太方便，我们可以将日志文件上传到本地的Linux机器中，我一般使用的是Ubuntu/Debian系的，现在一般的Linux发行系统都已经预装了rsyslog了，因此我们只需要配置一下即可． 配置rsyslog首先配置服务端，也即是我们使用的Linux系统主机.$ sudo vim /etc/rsyslog.conf找到1234567# provides UDP syslog reception#module(load=\"imudp\")#input(type=\"imudp\" port=\"514\")# provides TCP syslog reception#module(load=\"imtcp\")#input(type=\"imtcp\" port=\"514\" 一般只需要打开TCP就好，不过为了还有其他用途可以将UDP的也全部都打开，除去相应的#注释即可．修改后的样子1234567# provides UDP syslog receptionmodule(load=\"imudp\")input(type=\"imudp\" port=\"514\")# provides TCP syslog receptionmodule(load=\"imtcp\")input(type=\"imtcp\" port=\"514\" 这样还没完，我们还需要配置log存放的位置．进入/etc/rsyslog.d/目录，新建一个router.conf文件编辑添加12:fromhost-ip, isequal, \"192.168.1.1\" /var/spool/rsyslog/router.log&amp;~ 192.168.1.1表示路由器的地址后面路径就表示了上传到本地主机的log地址了最后的符号&amp;~表示了一个重定向规则，被用来告知rsyslog守护进程停止对日志消息的进一步处理，并且不要在本地写入。如果没有使用该重定向规则，那么所有的远程消息都会在写入上述描述的日志文件之外同时被写入到本地日志文件，这就意味着日志消息实际上被写了两次。 然后如果还有什么特殊需求的话，比如：像系统日志一样，自动打包之类的可以在/etc/logrotate.d/目录下面新建文件，然后进行添加．在这里我偷个懒，直接写在rsyslog文件里面． $ sudo vim /etc/logrotate.d/rsyslog随便找一个规则，将我们路由器log存放的地址写在上面即可 最后还有，需要重启一下rsyslog系统服务$ sudo systemctl restart rsyslog.service 查看一下是否在监听$ sudo netstat -tulpn |grep rsyslogd 以上服务端配置好了，客户端也就是路由器那里就很好配了．可以通过可视化的web界面进行管理，也可以直接命令行登陆进路由器,然后改配置文件的方式． 下面是我的路由器管理界面 改配置文件的话，就直接ssh连进路由器# vim /etc/config/system找到config system在下面添加即可1234567config system option hostname 'OpenWrt' option conloglevel '8' option cronloglevel '8' option log_ip '192.168.1.247' option log_port '514' option log_size '200' 然后保存并应用，过一会就可以在本机上看到路由上的log了 处理问题上面说了一大堆log的配置，最终的目的只是方便分析日志．而我们分析日志就是为了解决问题的．．．分析日志：发现有很多的这种信息daemon.warn odhcpd[903]: A default route is present but there is no public prefix on br-lan thus we don&#39;t announce a default route!这个是因为开启了IPv6的原因，我们用不上，关掉即可 总结我感觉问题不太可能是出现在IPv6上面的，虽然我关掉后确实断线的情况好了很多．．通过这次鼓捣，让我又对OpenWrt熟悉了不少，当然最大的收获还是rsyslog了，之前虽然知道有这么个东西，但一直没有机会去用上它，配置过一次后感觉以后就熟悉多了．","tags":[{"name":"Log","slug":"Log","permalink":"https://lusyoe.github.io/tags/Log/"}]},{"title":"OpenWrt之初相识篇","date":"2016-06-04T15:47:34.000Z","path":"2016/06/04/OpenWrt之初相识篇/","text":"最早是在几年前就知道了OpenWrt的，当时只是为了”翻墙”更方便点，才搜到这个东西的．．然而无奈能力有限，一直没法去把玩尝试它．去年刚好我哥买了一个很便宜的路由器，用不上就给我了．我想着这个反正弄坏了也没太大关系，就又去网上找各种资料了，什么不死uboot啦，什么高科固件一大堆的． 总之折腾了好几天终于是弄好了.看这高大上的界面，简直要甩原厂自带那个丑爆的界面好几条街．功能更是没法比．． 最让人兴奋的就是可以装各种第三方的软件了，其中就包含Shadowsocks翻墙工具，我最初的目的也就是这个了．作为一个技术人员，不能google查找资料，就算是不称职的啦．政治这种东西我们不关心，但是技术文档和问题解决方案这些却是必不可少的了．","tags":[{"name":"Router","slug":"Router","permalink":"https://lusyoe.github.io/tags/Router/"}]},{"title":"Linux软件篇之Docker","date":"2016-03-09T14:49:05.000Z","path":"2016/03/09/Linux软件篇之Docker/","text":"我是在2014年就开始接触docker的，那时候docker刚刚火起来，最开始只是把它当做是虚拟机的一种替代品吧，而且启动速度快，消耗的硬件资源也没一般虚拟机那么大，可以说是跟主机共享使用资源的，不像虚拟机，要一开始就固定的进行分配。。 在2015年的时候，我就开始尝试着在工作中使用它了。那时候刚做android系统开发，被那个编译环境搭建搞的欲死欲活的，就想有什么方法可以一键搭建哦。然后当时公司服务器都使用的是centos，但android编译环境可要求的是Ubuntu呀，没办法就想到了虚拟化。最后就又想到Docker了，在网上找了找，果然已经有国外的大神写好了针对CyanogenMod的dockerfile环境搭建了。拉下来一键就部署好了。 下面记录一下当时使用的笔记吧。 Ubuntu修改Docker服务启动默认数据文件存放位置默认Docker将数据文件都放在/var/lib/docker中，如果该分区不是很大的话，不利于后期的扩展，尤其是作为android源码项目来说的，因此可修改配置文件，使其数据存储路径指定在其他位置。 Upstart方式：编辑/etc/default/docker ，添加DOCKER_OPTS=&quot;-g /opt/docker&quot; 即可改到/opt/docker路径中。 Systemd方式：","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"},{"name":"Docker","slug":"Docker","permalink":"https://lusyoe.github.io/tags/Docker/"}]},{"title":"Linux软件篇之systemd","date":"2016-03-08T15:32:00.000Z","path":"2016/03/08/Linux软件篇之systemd/","text":"简介systemd是Linux下一种init软件，主要是用来管理系统服务的，当然了systemd不仅仅是可以管理系统服务，还有日志管理、系统资源管理等等，systemd可以说是非常强大也非常复杂的一种软件。 系统服务管理 激活开机启动服务 $ sudo systemctl enable [service-name] 取消开机启动服务 $ sudo systemctl disable [service-name] 查看是否开机启动服务 $ systemctl is-enable [service-name] 查看开机每个服务消耗的时间 $ systemd-analyze blame 查看开机消耗总时间 $ systemd-analyze 查看所有被激活的服务 $ systemctl list-units -t service 查看一个服务的状态 $ systemctl status [service-name] 启动、停止、重启一个服务 $ sudo systemctl start(stop、restart) [service-name] 重新加载一个服务(可以只加载服务的配置文件而不重启服务) $ sudo systemctl reload [service-name] 日志管理 查看启动日志(默认只保存本次启动的日志) $ sudo journalctl 查看某个服务的日志 $ sudo journalctl [service-path](如：/usr/sbin/sshd) 查看实时日志 $ sudo journalctl -f 重新载入systemd所有更改的配置，扫描新的或变动的单元 $ sudo systemctl daemon-reload 查看内核日志(不显示应用日志) $ sudo journalctl -k 查看某个路径的脚本的日志 $ sudo journalctl /bin/bash 显示日志占据的硬盘空间 $ sudo journalctl --disk-usage 以上都为常用的功能，当然还有需要添加自定义的服务，这个以后再说。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"}]},{"title":"Linux软件篇之tmux","date":"2016-03-07T10:31:24.000Z","path":"2016/03/07/Linux软件篇之tmux/","text":"tmux 是一款优秀的终端复用软件，它通过前缀键+操作键进行使用。tmux前缀键默认为Ctrl+b，可通过配置文件进行更改，后面会写到。tmux 分为会话(Session)、窗口(Window)和窗格(pane)。 快捷键会话(Session) 创建一个新的Session$ tmux new -s &quot;名称&quot; 在tmux中再创建一个SessionCtrl+b :new -s &quot;名称&quot; 切换不同的SessionCtrl+b s up(down)方向键 重命名当前SessionCtrl+b $ 退出当前Session$ exit 恢复最上面的一个Session$ tmux a 恢复指定Session$ tmux attach-session -t &lt;session-name&gt; 窗口(Window) 创建一个新的WindowCtrl+b c 重命名当前WindowCtrl+b , 创建一个指定名字的WindowCtrl+b :new-window -n &lt;window-name&gt; 切换不同的WindowCtrl+b number(位于window名字:前面的数字编号) 删除当前的WindowCtrl+b &amp; 窗格(Pane) 垂直分割窗口(一左一右2个窗格)Ctrl+b % 水平分割窗口(一上一下2个窗格)Ctrl+b &quot; 切换不同的窗格(Pane)Ctrl+b up(down、left、right上下左右方向键) 删除当前的窗格(Pane)Ctrl+b x 复制、粘贴文本 Ctrl+b [ 进入复制模式 Space 空格键开始复制指定的文本(类似vi的可视模式) Enter 回车，复制完成 Ctrl+b ] 粘贴文本 配置编辑~/.tmux.conf文件 修改前缀键为Ctrl+a(C-a)set -g prefix C-a 解除原来的Ctrl+bunbind C-b 其他的配置和快捷键可通过$ man tmux查看tmux的手册 总结一下我使用tmux最主要的还是看中它的现场恢复了。比如说：今天在服务器上进行编码修改，快到下班时间，不想等着加班搞完了再回去，可以直接关掉电脑走人，第二天来登陆服务器，直接$ tmux a即可完美回到前一天正在修改的地方，继续接着改就可以了。不然每次下班第二天来又要找半天前一天要改的地方了。。还有一个好处是tmux只通过一个ssh连接就可以实现多个终端操作了，大家都知道在工作中，一个终端的使用是远远不够的，如果不用类似tmux这样的软件，就必须要进行多次ssh连接了。最后需要注意一下的是: 使用tmux恢复时，必须要保证在上一次断开连接到这次恢复之间，服务器(主机)不能重启，一旦重启了就什么都没了。。","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"}]},{"title":"Linux软件篇之ssh","date":"2016-03-06T08:16:57.000Z","path":"2016/03/06/Linux软件篇之ssh/","text":"ssh 可以说是最常用的一个远程登陆服务器进行控制的软件了，总结一下。一般的Linux发行版都自带了ssh客户端，如果需要安装服务端的话，执行1$ sudo apt-get install openssh-server 生成公私密钥 本机$ ssh-keygen 指定$ ssh-keygen -t rsa -C &quot;xxx@xx.com&quot; 无需密码登陆服务器 将公钥(一般位于~/.ssh/id_rsa.pub)内容，存放到远程服务器指定账户的Home目录下面的~/.ssh/authorized_keys中,如果没有authorized_keys文件的话就新键一个。在这里有一个很方便的命令可以直接使用：$ ssh-copy-id 服务器用户名@域名或ip下次登陆服务器就无需再次输入密码了,登陆命令：$ ssh username@addr 快速连接通过config配置文件，可无需每次都输入远程用户名和地址即可进行连接。在~/.ssh下新建config文件，编辑添加内容如下：1234Host testHostName xxx.xxx.xxx.xxx(远程服务器ip)User root(登陆远程的用户名)Port 22(登陆的端口) 之后连接直接使用：$ ssh test即可 远程与本地传输文件通过scp命令进行本地与远程之间的数据传递. 从远程主机拷贝到本地$ scp 远程user@addr:文件路径(默认用户home目录) 本地路径(同上) 将本地文件拷贝到远程主机$ scp 本地文件路径 远程user@addr:文件路径(默认用户home目录) 拷贝目录(递归)$ scp -r","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"}]},{"title":"Linux软件篇","date":"2016-03-06T07:27:58.000Z","path":"2016/03/06/Linux软件篇/","text":"总结一下，在Linux下使用过的一些软件，不包括开发使用的 axel 终端下载器可通过 -n x(数字) 设置下载时使用的线程数 ,如：1$ axel -n 5 &lt;URL&gt; 新立得包依赖管理器 synaptic虽然一般直接使用apt-get的比较多，不过在处理依赖方面，这个软件还是挺强大的 查找库文件以及对应包的神器apt-file第一次安装成功后，需要更新数据库$ apt-file update查找包信息或库文件所在包$ apt-file search xxx 文件编码转换iconv，一般情况下使用方法：$ iconv -f 原来编码 -t 新编码 文件名 词典goldendict 文本比较工具Meld Diff Mac 托盘效果Cairo-dock 可视化系统管理面板(web端)ajenti 网络端口流量监控iftop 截图工具shutter markdown可视化工具remarkable tty显示中文fbterm 摄像头软件Camorama 笔记本数字小键盘工具numlockx 激活小键盘 numlockx on 禁用小键盘 numlockx off 基于终端的文件浏览器ranger","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"}]},{"title":"Ubuntu基础操作","date":"2016-03-06T06:57:42.000Z","path":"2016/03/06/Ubuntu基础操作/","text":"将早期学习Linux的一些笔记整理下 安装中文man手册1$ sudo apt-get install manpages-zh 查看系统发行版本1$ lsb_release -a 查看内核版本1$ uname -a 历史命令 查看已记录的所有历史命令$ history 执行指定编号的历史命令$ !N N为命令前面的编号 修改历史命令，然后退出时执行 $ fc N 开机自动执行命令编辑/etc/rc.local文件，在exit 0前面添加命令即可 新装系统，切换root失败首次安装好系统后，root用户没有设置默认密码，因此执行su命令会报错设置root密码1$ sudo passwd root","tags":[{"name":"Linux","slug":"Linux","permalink":"https://lusyoe.github.io/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"https://lusyoe.github.io/tags/Ubuntu/"}]},{"title":"Hello World","date":"2016-03-05T05:14:52.000Z","path":"2016/03/05/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]